{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TESS Back ML","text":"<p>This is a Python package to create training data to be used for a neural network (NN)  model that predicts the TESS Full Frame Image (FFI) background signal, in particular,  the time-changing scattered light.</p> <p>This animation shows the scattered light of a TESS FFI. The original 2048 x 2048 pixel  image was downsized to 128 x 128 pixels to be memory efficient.</p> <p></p> <p>The next figure shows the vector maps (distance, elevation, and azimuth angles) for  Earth and Moon with respect to the camera boresight. These maps have the same shape as the scatter light cube shown above.</p> <p></p>"},{"location":"#install","title":"Install","text":"<p>Install from this GitHub repository with</p> <pre><code>pip install git+https://github.com/jorgemarpa/tess-backml\n</code></pre> <p>PyPI will available shortly.</p>"},{"location":"#usage","title":"Usage","text":"<p>To get the data follow the steps:</p> <pre><code>from tess_backml import Background_Data\n\n# initialize the object for given sector/camera/ccd\n# will do 16x16 pixel binning\ntess_bkg = BackgroundCube(\n    sector=1, camera=1, ccd=1, img_bin=16, downsize=\"binning\"\n)\n\n# get the flux data from MAST/AWS, compute scatter light and downsize\ntess_bkg.get_scatter_light_cube(frames=None, mask_straps=True, plot=False)\n# compute the vector maps for the Earth and Moon\ntess_bkg.get_vector_maps(ang_size=True)\n\n# make an animation of the scatter light cube\ntess_bkg.animate_data(data=\"sl\", save=False, step=10);\n\n# save data to disk\ntess_bkg.save_data(save_maps=True)\n</code></pre> <p>Or you can run a Python script <code>build_dataset.py</code> in the terminal (plotting flag is optional and will add run time): <pre><code>usage: build_dataset.py [-h] [--sector SECTOR] [--camera CAMERA] [--ccd CCD] [--downsize DOWNSIZE] [--image-bin IMG_BIN] [--plot]\n                        [--out-dir OUT_DIR]\n\nBuild TESS FFI background dataset for a Sector/Camera/CCD.\n\noptions:\n  -h, --help           show this help message and exit\n  --sector SECTOR      TESS sector.\n  --camera CAMERA      TESS camera.\n  --ccd CCD            TESS camera.\n  --downsize DOWNSIZE  Method for downsizing the image, one of [sparse, binning].\n  --image-bin IMG_BIN  Image binning size, must divide 2048.\n  --plot               Plot target light curve.\n  --out-dir OUT_DIR    Outputh directory path where files and figures will be saved.\n</code></pre> For example <pre><code>python build_dataset.py --sector 3 --camera 1 --ccd 2 --image-bin 16 --downsize binning --plot\n</code></pre></p> <p>The script will save <code>npz</code> files with the following dictionary: <pre><code>\"scatter_cube\":   the data cube with the scatter light, shape [nt, 128, 128] depending on the binsize (16)\n\"time\":           time array in JD\n\"cadenceno\":      cadence number array\n\"earth_alt\":      Earth altitude angle from the camera boresight\n\"earth_az\":       Earth azimuth angle from the camera boresight\n\"earth_dist\":     Earth distance from the camera boresight\n\"moon_alt\":       Moon altitude angle from the camera boresight\n\"moon_az\":        Moon azimuth angle from the camera boresight\n\"moon_dist\":      Moon distance from the camera boresight\n\"earth_alt_map\":  Earth altitude angle map for every pixel, same shape as `scatter_cube`\n\"earth_az_map\":   Earth azimuth angle map for every pixel \n\"earth_dist_map\": Earth angular size map for every pixel \n\"moon_alt_map\":   Moon altitude angle map for every pixel \n\"moon_az_map\":    Moon azimuth angle map for every pixel \n\"moon_dist_map\":  Moon angular size map for every pixel \n</code></pre></p> <p>Also check out the Jupyter notebook tutorial here.</p>"},{"location":"bkg_data/","title":"<code>BackgroundCube</code>","text":""},{"location":"bkg_data/#src.tess_backml.BackgroundCube","title":"BackgroundCube","text":"<p>               Bases: <code>object</code></p> <p>Class for creating TESS Full Frame Image background cubes to train a deep learning model that predicts the scatter light.</p> <p>It uses <code>tesscube</code> to retrieve FFI cubes from MAST/AWS, does spatia binning to downsize the 2k x 2k image, e.g. to 128 x 128 pixels. It uses <code>tessvectors</code> to obtain Earth/Moon angles/distances with respect to each TESS camera and creates a pixel map for each object angle and distance with the same resolution as the downsize FFI cube.</p> <p>Package the data into local files or returns batches fot ML training.</p> <p>Parameters:</p> <ul> <li> <code>sector</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>TESS sector number. Must be between 1 and 100. Default is 1.</p> </li> <li> <code>camera</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>TESS camera number. Must be between 1 and 4. Default is 1.</p> </li> <li> <code>ccd</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>TESS CCD number. Must be between 1 and 4. Default is 1.</p> </li> <li> <code>img_bin</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>Binning factor for spatial downsampling of the FFI image. Must be a divisor of 2048. Default is 16. #</p> </li> <li> <code>downsize</code>               (<code>str</code>, default:                   <code>'binning'</code> )           \u2013            <p>Method for spatial downsampling. Options are 'binning' (median binning) or 'sparse' (select sparse pixels). Default is \"binning\".</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.__init__","title":"__init__","text":"<pre><code>__init__(\n    sector: int = 1,\n    camera: int = 1,\n    ccd: int = 1,\n    img_bin: int = 16,\n    downsize: str = \"binning\",\n)\n</code></pre>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.plot_dark_frame","title":"plot_dark_frame","text":"<pre><code>plot_dark_frame(mask_straps: bool = False)\n</code></pre> <p>Displays diagnostic plots of the darkest frame and associated masks.</p> <p>Shows the darkest FFI frame, the generated star mask, and optionally the strap mask.</p> <p>Parameters:</p> <ul> <li> <code>mask_straps</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also fetches and plots the strap mask. Requires the <code>_get_straps_mask</code> method to have been called or will call it. Default is False.</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.get_scatter_light_cube","title":"get_scatter_light_cube","text":"<pre><code>get_scatter_light_cube(\n    plot: bool = False,\n    mask_straps: bool = False,\n    frames: Optional[Tuple] = None,\n    rolling: bool = True,\n    errors: bool = True,\n)\n</code></pre> <p>Computes the scattered light cube by processing FFIs.</p> <p>This method orchestrates the process of: 1. Identifying dark frames (<code>_get_dark_frame_idx</code>). 2. Creating a star mask (<code>_get_star_mask</code>). 3. Optionally creating a strap mask (<code>_get_straps_mask</code>). 4. Defining background pixels (excluding stars and optionally straps). 5. Calculating the static scene by median-combining dark frames (<code>_get_static_scene</code>). 6. Iterating through FFIs (all or a specified range):    - Fetching FFI data.    - Applying the background pixel mask (masking stars/straps).    - Subtracting the static scene.    - Downsampling the result using the specified <code>downsize</code> method ('binning' or 'sparse'). 7. Storing the final scattered light cube.</p> <p>Parameters:</p> <ul> <li> <code>plot</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, displays the diagnostic dark frame plots after mask creation. Default is False.</p> </li> <li> <code>mask_straps</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, masks out pixels corresponding to CCD straps in addition to stars. Default is False.</p> </li> <li> <code>frames</code>               (<code>Optional[Tuple]</code>, default:                   <code>None</code> )           \u2013            <p>Specifies a range of frame indices to process. Can be: - (N,): Process frames from 0 up to (but not including) N. - (start, stop): Process frames from index <code>start</code> up to <code>stop</code>. - (start, stop, step): Process frames from <code>start</code> to <code>stop</code> with <code>step</code>. If None, processes all frames. Default is None.</p> </li> <li> <code>rolling</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, pooling downsizing will be done with an iterative rolling windown and stride  that will match the output desired shape, this will make the downsizing step slower. If False, pooling downsizing will use fixed window and stride.</p> </li> <li> <code>errors</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Retrieve and propagate errors</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.get_vector_maps","title":"get_vector_maps","text":"<pre><code>get_vector_maps(ang_size: bool = True)\n</code></pre> <p>Generates pixel-wise maps of Earth and Moon positions and sizes.</p> <p>Fetches spacecraft orientation and Earth/Moon position vectors using <code>tessvectors</code>. Then, for both Earth and Moon, it calls <code>_get_object_vectors</code> to compute 3D maps (time, row, col) representing the distance/angular size, altitude, and azimuth for each pixel in the downsampled grid over time. Also stores the boresight vectors for reference.</p> <p>Parameters:</p> <ul> <li> <code>ang_size</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the 'dist' maps and vectors represent angular size (degrees). If False, they represent physical distance ([m] for maps). Default is True.</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.animate_data","title":"animate_data","text":"<pre><code>animate_data(\n    data: str = \"sl\",\n    step: int = 10,\n    file_name: Optional[str] = None,\n    save: bool = False,\n)\n</code></pre> <p>Creates and optionally saves an animation of the processed data cubes.</p> <p>Generates an animation showing the time evolution of either the scattered light cube or one of the Earth/Moon angle/distance maps.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str</code>, default:                   <code>'sl'</code> )           \u2013            <p>Which data cube to animate. Options are: - 'sl': Scattered light cube (<code>scatter_cube</code>). - 'earth_alt': Earth altitude map (<code>earth_maps['alt']</code>). - 'earth_az': Earth azimuth map (<code>earth_maps['az']</code>). - 'earth_dist': Earth distance/angular size map (<code>earth_maps['dist']</code>). - 'moon_alt', 'moon_az', 'moon_dist': Corresponding Moon maps. Default is \"sl\".</p> </li> <li> <code>step</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Frame step for the animation (e.g., step=10 shows every 10th frame). Default is 10.</p> </li> <li> <code>file_name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Filename for saving the animation as a GIF. If None and <code>save</code> is True, a default filename is generated. Default is None.</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, saves the animation to the specified <code>file_name</code> (or default). If False, attempts to display the animation directly (requires IPython). Default is False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HTML or None</code>           \u2013            <p>If <code>save</code> is False and IPython is available, returns an HTML object for displaying the animation. Otherwise returns None.</p> </li> </ul>"},{"location":"tutorial_1/","title":"Tutorial 1","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[1]: Copied! <pre># basic imports\nimport os\nimport numpy as np\nfrom tess_backml import BackgroundCube\nfrom tess_backml.utils import pooling_2d\nimport matplotlib.pyplot as plt\n\n# increase animation frame limits\nimport matplotlib\nmatplotlib.rcParams[\"animation.embed_limit\"] = 2**128\n</pre> # basic imports import os import numpy as np from tess_backml import BackgroundCube from tess_backml.utils import pooling_2d import matplotlib.pyplot as plt  # increase animation frame limits import matplotlib matplotlib.rcParams[\"animation.embed_limit\"] = 2**128 In\u00a0[2]: Copied! <pre># define sector/camera/ccd\nsector = 2\ncamera = 1\nccd = 1\nbinsize = 8\n</pre> # define sector/camera/ccd sector = 2 camera = 1 ccd = 1 binsize = 8 In\u00a0[3]: Copied! <pre>bkg_data = BackgroundCube(\n    sector=sector, camera=camera, ccd=ccd, img_bin=binsize, downsize=\"binning\"\n)\nprint(bkg_data)\n</pre> bkg_data = BackgroundCube(     sector=sector, camera=camera, ccd=ccd, img_bin=binsize, downsize=\"binning\" ) print(bkg_data) <pre>TESS FFI Background object (Sector, Camera, CCD, N times): 2, 1, 1, 1235\n</pre> In\u00a0[4]: Copied! <pre>bkg_data.get_scatter_light_cube(frames=None, mask_straps=True, plot=True, rolling=True)\n</pre> bkg_data.get_scatter_light_cube(frames=None, mask_straps=True, plot=True, rolling=True) <pre>INFO:tess_backml:Computing sector darkest frames...\nINFO:tess_backml:Computing star mask...\n</pre> <pre>INFO:tess_backml:Getting FFI flux cube...\nINFO:tess_backml:Computing average static scene from darkes frames...\n</pre> <pre>Iterating frames: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1245/1245 [1:25:30&lt;00:00,  4.12s/it]\n</pre> <p>We can animate the scatter light cube for visualization</p> In\u00a0[6]: Copied! <pre>bkg_data.animate_data(data=\"sl\", save=False, step=10);\n</pre> bkg_data.animate_data(data=\"sl\", save=False, step=10); <pre>INFO:matplotlib.animation:Animation.save using &lt;class 'matplotlib.animation.HTMLWriter'&gt;\n</pre> In\u00a0[7]: Copied! <pre>bkg_data.get_vector_maps(ang_size=True)\n</pre> bkg_data.get_vector_maps(ang_size=True) <pre>INFO:root:Retrieving TESSVector from: https://heasarc.gsfc.nasa.gov/docs/tess/data/TESSVectors/Vectors/FFI_Cadence/TessVectors_S002_C1_FFI.csv\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1245/1245 [00:02&lt;00:00, 471.70it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1245/1245 [00:02&lt;00:00, 465.24it/s]\n</pre> <p>We can inspect these maps for a single frame</p> In\u00a0[8]: Copied! <pre>tdx = 500\n\nfig, ax = plt.subplots(2, 3, figsize=(9,6), sharex=True, sharey=True)\n\nfig.suptitle(\n    f\"Sector {sector} Camera {camera} CCD {ccd} | \"\n    f\"Frame {tdx} Time {bkg_data.time[tdx]:.3f}\"\n)\nax[0, 0].imshow(bkg_data.earth_maps[\"alt\"][tdx], origin=\"lower\")\nax[0, 1].imshow(bkg_data.earth_maps[\"az\"][tdx], origin=\"lower\")\nax[0, 2].imshow(bkg_data.earth_maps[\"dist\"][tdx], origin=\"lower\")\n\nax[0, 0].set_title(\"Earth Altitude Angle\")\nax[0, 1].set_title(\"Earth Azimuth Angle\")\nax[0, 2].set_title(\"Earth Angular Size\")\n\nax[1, 0].imshow(bkg_data.moon_maps[\"alt\"][tdx], origin=\"lower\")\nax[1, 1].imshow(bkg_data.moon_maps[\"az\"][tdx], origin=\"lower\")\nax[1, 2].imshow(bkg_data.moon_maps[\"dist\"][tdx], origin=\"lower\")\n\nax[1, 0].set_title(\"Moon Altitude Angle\")\nax[1, 1].set_title(\"Moon Azimuth Angle\")\nax[1, 2].set_title(\"Moon Angular Size\")\n\nax[0, 0].set_ylabel(\"Pixel Row\")\nax[1, 0].set_ylabel(\"Pixel Row\")\nax[1, 0].set_xlabel(\"Pixel Column\")\nax[1, 1].set_xlabel(\"Pixel Column\")\nax[1, 2].set_xlabel(\"Pixel Column\")\n\nplt.show()\n</pre> tdx = 500  fig, ax = plt.subplots(2, 3, figsize=(9,6), sharex=True, sharey=True)  fig.suptitle(     f\"Sector {sector} Camera {camera} CCD {ccd} | \"     f\"Frame {tdx} Time {bkg_data.time[tdx]:.3f}\" ) ax[0, 0].imshow(bkg_data.earth_maps[\"alt\"][tdx], origin=\"lower\") ax[0, 1].imshow(bkg_data.earth_maps[\"az\"][tdx], origin=\"lower\") ax[0, 2].imshow(bkg_data.earth_maps[\"dist\"][tdx], origin=\"lower\")  ax[0, 0].set_title(\"Earth Altitude Angle\") ax[0, 1].set_title(\"Earth Azimuth Angle\") ax[0, 2].set_title(\"Earth Angular Size\")  ax[1, 0].imshow(bkg_data.moon_maps[\"alt\"][tdx], origin=\"lower\") ax[1, 1].imshow(bkg_data.moon_maps[\"az\"][tdx], origin=\"lower\") ax[1, 2].imshow(bkg_data.moon_maps[\"dist\"][tdx], origin=\"lower\")  ax[1, 0].set_title(\"Moon Altitude Angle\") ax[1, 1].set_title(\"Moon Azimuth Angle\") ax[1, 2].set_title(\"Moon Angular Size\")  ax[0, 0].set_ylabel(\"Pixel Row\") ax[1, 0].set_ylabel(\"Pixel Row\") ax[1, 0].set_xlabel(\"Pixel Column\") ax[1, 1].set_xlabel(\"Pixel Column\") ax[1, 2].set_xlabel(\"Pixel Column\")  plt.show() In\u00a0[9]: Copied! <pre>bkg_data.scatter_cube.shape, bkg_data.earth_maps[\"dist\"].shape\n</pre> bkg_data.scatter_cube.shape, bkg_data.earth_maps[\"dist\"].shape Out[9]: <pre>((1235, 256, 256), (1235, 256, 256))</pre> In\u00a0[11]: Copied! <pre>bkg_data.bin_time_axis(bin_size=2.0)\nbkg_data.time_bin.shape, bkg_data.scatter_cube_bin.shape, bkg_data.earth_maps_bin[\"dist\"].shape\n</pre> bkg_data.bin_time_axis(bin_size=2.0) bkg_data.time_bin.shape, bkg_data.scatter_cube_bin.shape, bkg_data.earth_maps_bin[\"dist\"].shape Out[11]: <pre>((312,), (312, 256, 256), (312, 256, 256))</pre> In\u00a0[12]: Copied! <pre># save data to disk\nfname = f\"./data/ffi_cubes_bin{bkg_data.img_bin}_sector{sector:03}_{camera}-{ccd}_light.npz\"\nprint(fname)\nbkg_data.save_data_npz(out_file=fname, save_maps=True)\n</pre> # save data to disk fname = f\"./data/ffi_cubes_bin{bkg_data.img_bin}_sector{sector:03}_{camera}-{ccd}_light.npz\" print(fname) bkg_data.save_data_npz(out_file=fname, save_maps=True) <pre>./data/ffi_cubes_bin8_sector002_1-1_light.npz\n</pre> In\u00a0[13]: Copied! <pre>data = np.load(fname, )\ndata.items()\n</pre> data = np.load(fname, ) data.items() Out[13]: <pre>ItemsView(NpzFile './data/ffi_cubes_bin8_sector002_1-1_light.npz' with keys: scatter_cube, time, cadenceno, earth_alt, earth_az...)</pre> In\u00a0[14]: Copied! <pre>data[\"scatter_cube\"].shape, data[\"earth_alt_map\"].shape\n</pre> data[\"scatter_cube\"].shape, data[\"earth_alt_map\"].shape Out[14]: <pre>((1235, 256, 256), (1235, 256, 256))</pre> In\u00a0[15]: Copied! <pre>bar = plt.imshow(data[\"scatter_cube\"][1180], origin=\"lower\", vmin=0, vmax=120,)\nplt.colorbar(bar)\nplt.show()\n</pre> bar = plt.imshow(data[\"scatter_cube\"][1180], origin=\"lower\", vmin=0, vmax=120,) plt.colorbar(bar) plt.show() <p>Or save only the scatter light cube in its binned version to <code>FITS</code> file.</p> In\u00a0[25]: Copied! <pre>fname = f\"./data/ffi_cubes_bin{bkg_data.img_bin}_sector{sector:03}_{camera}-{ccd}_light.fits\"\nprint(fname)\n_ = bkg_data.save_to_fits(out_file=fname, binned=True)\n</pre> fname = f\"./data/ffi_cubes_bin{bkg_data.img_bin}_sector{sector:03}_{camera}-{ccd}_light.fits\" print(fname) _ = bkg_data.save_to_fits(out_file=fname, binned=True) <pre>./data/ffi_cubes_bin8_sector002_1-1_light.fits\n</pre> In\u00a0[26]: Copied! <pre>from astropy.io import fits\n</pre> from astropy.io import fits In\u00a0[27]: Copied! <pre>hdul = fits.open(fname)\nhdul.info()\n</pre> hdul = fits.open(fname) hdul.info() <pre>Filename: ./data/ffi_cubes_bin8_sector002_1-1_light.fits\nNo.    Name      Ver    Type      Cards   Dimensions   Format\n  0  PRIMARY       1 PrimaryHDU      62   ()      \n  1  SCATTER LIGHT CUBE    1 ImageHDU        10   (2, 312, 256, 256)   float64   \n  2  PIXEL COUNTS    1 ImageHDU         8   (256, 256)   int64   \n  3  TIME          1 BinTableHDU     13   312R x 1C   [D]   \n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorial_1/#tess-background-data","title":"TESS Background data\u00b6","text":"<p>This notebook shows how to use <code>BackgroundCube</code> to get TESS Full Frame Images (FFI) scatter light component and Earth/Moon angles as pixel maps for every camera/ccd in the instrument.</p> <p>This data could be used to train a machine learning model or used directly to correct the scatter light contribution in TESS cutouts.</p>"},{"location":"tutorial_1/#initialize","title":"Initialize\u00b6","text":"<p>We initialize the object with a specific Sectopr/Camera/CCD, an image bin size, and a method for downsizing (default if 'binning')</p>"},{"location":"tutorial_1/#get-flux-data","title":"Get Flux Data\u00b6","text":"<p>Compute the binned scatter light cube which does:</p> <ul> <li>Finds the darkest frame in the sector to build a star mask and a saturated pixel mask</li> <li>Adds a strap mask</li> <li>Pulls the FFI flux data from the cloud</li> <li>Downsize the image by doing median 8x8 (effective) binning, masking out stars, straps, and saturated pixels<ul> <li>If <code>rolling=True</code> downsizing is done with iterative rolling windows to get to the desired output shape, this will increase ~25% more the computing time, but will give more robust estimations around bright stars, saturated pixes, and straps.</li> </ul> </li> <li>The resulting scatter light cube has shape [nt, 256, 256]</li> </ul> <p>Note: this is the most time consuming step, most of the computing time is spend in I/O (~50-60% of each iteration). This can be speed up if we run this notebook in TIKE and take advantage of AWS, if that's the case, a typical Sector/Camera/CCD should take ~30-40 minutes, depending of load. In a local machine, it can take up to 1h depending on internet connection.</p>"},{"location":"tutorial_1/#compute-angle-maps","title":"Compute Angle Maps\u00b6","text":"<p>Now we compute the Earth/Moon vector maps:</p> <ul> <li>We pull the Earth/Moon distance, azimuth, and elevation angles from the engineering files. This values a w.r.t. each camera's boresight and changes for each frame in the sector. Using trigonometric rules, we compute these values for each pixel in the downsized grid [nt, 128, 128].</li> <li>If <code>ang_size == True</code> then the Earth/Moon distances are changed to angular size.</li> </ul>"},{"location":"tutorial_1/#time-binning","title":"Time binning\u00b6","text":"<p>We can do time binning to reduce size of the cubes and save memory/storage. The function <code>bkg_data.bin_time_axis()</code> takes the parameter <code>bin_size</code> as the size of the bin in hours. This creates new attributes (e.g. <code>bkg_data.time_bin</code> and <code>bkg_data.scatter_cube_bin</code>)</p>"},{"location":"tutorial_1/#save-data","title":"Save Data\u00b6","text":"<p>The computed scatter light, angle maps, and times values can be saved to disk as a <code>npz</code> file for future use. This will save the cubes/vectors with all times, no binning.</p>"},{"location":"utils/","title":"<code>Utils</code>","text":""},{"location":"utils/#src.tess_backml.utils","title":"utils","text":""},{"location":"utils/#src.tess_backml.utils.pooling_2d","title":"pooling_2d","text":"<pre><code>pooling_2d(\n    input_array: ndarray,\n    kernel_size: int = 4,\n    stride: int = 4,\n    padding: Union[int, Tuple[int, int]] = 0,\n    stat: Callable = nanmedian,\n) -&gt; ndarray\n</code></pre> <p>Performs 2D pooling on the input array with optional zero padding.</p> <p>Parameters:</p> <ul> <li> <code>input_array</code>               (<code>ndarray</code>)           \u2013            <p>A 2D numpy array representing the input data.</p> </li> <li> <code>kernel_size</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The size of the pooling kernel (square), by default 4. Must be positive.</p> </li> <li> <code>stride</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The stride of the pooling operation, by default 4. Must be positive.</p> </li> <li> <code>padding</code>               (<code>Union[int, Tuple[int, int]]</code>, default:                   <code>0</code> )           \u2013            <p>Padding to be added to the input array before pooling. - If an int <code>p</code>: applies symmetric padding of <code>p</code> zeros.   <code>p</code> rows of zeros are added to the top and <code>p</code> to the bottom.   <code>p</code> columns of zeros are added to the left and <code>p</code> to the right. - If a tuple <code>(p_h, p_w)</code>: applies <code>p_h</code> rows of zeros to the top and <code>p_h</code> to the bottom,   and <code>p_w</code> columns of zeros to the left and <code>p_w</code> to the right. Padding values must be non-negative. Default is 0 (no padding).</p> </li> <li> <code>stat</code>               (<code>Callable</code>, default:                   <code>nanmedian</code> )           \u2013            <p>The aggregation function to use for pooling (e.g., np.mean, np.max, np.nanmedian), by default np.nanmedian.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A 2D numpy array representing the pooled output.</p> </li> </ul>"},{"location":"utils/#src.tess_backml.utils.plot_img","title":"plot_img","text":"<pre><code>plot_img(\n    img: ndarray,\n    scol_2d: Optional[ndarray] = None,\n    srow_2d: Optional[ndarray] = None,\n    plot_type: str = \"img\",\n    extent: Optional[Tuple] = None,\n    cbar: bool = True,\n    ax: Optional[Axes] = None,\n    title: str = \"\",\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    cnorm: Optional[Normalize] = None,\n    bar_label: str = \"Flux [e-/s]\",\n) -&gt; Axes\n</code></pre> <p>Plots an image with optional scatter points and colorbar.</p> <p>Parameters:</p> <ul> <li> <code>img</code>               (<code>ndarray</code>)           \u2013            <p>The 2D image data to be plotted.</p> </li> <li> <code>scol_2d</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>The column coordinates of scatter points, by default None.</p> </li> <li> <code>srow_2d</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>The row coordinates of scatter points, by default None.</p> </li> <li> <code>plot_type</code>               (<code>str</code>, default:                   <code>'img'</code> )           \u2013            <p>The type of plot to create ('img' or 'scatter'), by default \"img\".</p> </li> <li> <code>extent</code>               (<code>Optional[Tuple]</code>, default:                   <code>None</code> )           \u2013            <p>The extent of the image (left, right, bottom, top), by default None.</p> </li> <li> <code>cbar</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to display a colorbar, by default True.</p> </li> <li> <code>ax</code>               (<code>Optional[Axes]</code>, default:                   <code>None</code> )           \u2013            <p>The matplotlib Axes object to plot on, by default None. If None, a new figure and axes are created.</p> </li> <li> <code>title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the plot, by default \"\".</p> </li> <li> <code>vmin</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>The minimum value for the colormap, by default None.</p> </li> <li> <code>vmax</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>The maximum value for the colormap, by default None.</p> </li> <li> <code>cnorm</code>               (<code>Optional[Normalize]</code>, default:                   <code>None</code> )           \u2013            <p>Custom color normalization, by default None.</p> </li> <li> <code>bar_label</code>               (<code>str</code>, default:                   <code>'Flux [e-/s]'</code> )           \u2013            <p>The label for the colorbar, by default \"Flux [e-/s]\".\"</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>axes</code>           \u2013            </li> </ul>"},{"location":"utils/#src.tess_backml.utils.animate_cube","title":"animate_cube","text":"<pre><code>animate_cube(\n    cube: ndarray,\n    scol_2d: Optional[ndarray] = None,\n    srow_2d: Optional[ndarray] = None,\n    cadenceno: Optional[ndarray] = None,\n    time: Optional[ndarray] = None,\n    plot_type: str = \"img\",\n    extent: Optional[Tuple] = None,\n    interval: int = 200,\n    repeat_delay: int = 1000,\n    step: int = 1,\n    suptitle: str = \"\",\n    bar_label: str = \"Flux [e-/s]\",\n) -&gt; FuncAnimation\n</code></pre> <p>Animates a 3D data cube (time series of 2D images).</p> <p>Parameters:</p> <ul> <li> <code>cube</code>               (<code>ndarray</code>)           \u2013            <p>The 3D data cube to be animated (time, row, column).</p> </li> <li> <code>scol_2d</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>The column coordinates of scatter points, by default None.</p> </li> <li> <code>srow_2d</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>The row coordinates of scatter points, by default None.</p> </li> <li> <code>cadenceno</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>Cadence numbers corresponding to the time axis, by default None.</p> </li> <li> <code>time</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>Time values corresponding to the time axis, by default None.</p> </li> <li> <code>plot_type</code>               (<code>str</code>, default:                   <code>'img'</code> )           \u2013            <p>The type of plot to create ('img' or 'scatter'), by default \"img\".</p> </li> <li> <code>extent</code>               (<code>Optional[Tuple]</code>, default:                   <code>None</code> )           \u2013            <p>The extent of the images (left, right, bottom, top), by default None.</p> </li> <li> <code>interval</code>               (<code>int</code>, default:                   <code>200</code> )           \u2013            <p>Delay between frames in milliseconds, by default 200.</p> </li> <li> <code>repeat_delay</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Delay in milliseconds before repeating the animation, by default 1000.</p> </li> <li> <code>step</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Step size for frame selection, by default 1.</p> </li> <li> <code>suptitle</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Overall title for the animation figure, by default \"\".</p> </li> <li> <code>bar_label</code>               (<code>str</code>, default:                   <code>'Flux [e-/s]'</code> )           \u2013            <p>The label for the colorbar, by default \"Flux [e-/s]\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FuncAnimation</code>           \u2013            <p>The matplotlib FuncAnimation object.</p> </li> </ul>"}]}