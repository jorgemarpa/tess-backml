{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TESS Back ML","text":"<p>This is a Python package to create training data to be used for a neural network (NN)  model that predicts the TESS Full Frame Image (FFI) background signal, in particular,  the time-changing scattered light.</p> <p>This animation shows the scattered light of a TESS FFI. The original 2048 x 2048 pixel  image was downsized to 128 x 128 pixels to be memory efficient.</p> <p></p> <p>The next figure shows the vector maps (distance, elevation, and azimuth angles) for  Earth and Moon with respect to the camera boresight. These maps have the same shape as the scatter light cube shown above.</p> <p></p>"},{"location":"#install","title":"Install","text":"<p>Install from this GitHub repository with</p> <pre><code>pip install git+https://github.com/jorgemarpa/tess-backml\n</code></pre> <p>PyPI will available shortly.</p>"},{"location":"#usage","title":"Usage","text":"<p>To get the data follow the steps:</p> <pre><code>from tess_backml import Background_Data\n\n# initialize the object for given sector/camera/ccd\n# will do 16x16 pixel binning\ntess_bkg = BackgroundCube(\n    sector=1, camera=1, ccd=1, img_bin=16, downsize=\"binning\"\n)\n\n# get the flux data from MAST/AWS, compute scatter light and downsize\ntess_bkg.get_scatter_light_cube(frames=None, mask_straps=True, plot=False)\n# compute the vector maps for the Earth and Moon\ntess_bkg.get_vector_maps(ang_size=True)\n\n# make an animation of the scatter light cube\ntess_bkg.animate_data(data=\"sl\", save=False, step=10);\n\n# save data to disk\ntess_bkg.save_data(save_maps=True)\n</code></pre> <p>Or you can run a Python script in the terminal (plotting flag is optional and will add run time): <pre><code>python build_dataset.py --sector 3 --camera 1 --ccd 2 --image-bin 16 --downsize binning --plot\n</code></pre></p> <p>Also check out the Jupyter notebook tutorial here.</p>"},{"location":"bkg_data/","title":"<code>BackgroundCube</code>","text":""},{"location":"bkg_data/#src.tess_backml.BackgroundCube","title":"BackgroundCube","text":"<p>               Bases: <code>object</code></p> <p>Class for creating TESS Full Frame Image background cubes to train a deep learning model that predicts the scatter light.</p> <p>It uses <code>tesscube</code> to retrieve FFI cubes from MAST/AWS, does spatia binning to downsize the 2k x 2k image, e.g. to 128 x 128 pixels. It uses <code>tessvectors</code> to obtain Earth/Moon angles/distances with respect to each TESS camera and creates a pixel map for each object angle and distance with the same resolution as the downsize FFI cube.</p> <p>Package the data into local files or returns batches fot ML training.</p> <p>Parameters:</p> <ul> <li> <code>sector</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>TESS sector number. Must be between 1 and 100. Default is 1.</p> </li> <li> <code>camera</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>TESS camera number. Must be between 1 and 4. Default is 1.</p> </li> <li> <code>ccd</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>TESS CCD number. Must be between 1 and 4. Default is 1.</p> </li> <li> <code>img_bin</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>Binning factor for spatial downsampling of the FFI image. Must be a divisor of 2048. Default is 16. #</p> </li> <li> <code>time_bin</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Binning factor for the time axis. Default is 1 (no binning).</p> </li> <li> <code>downsize</code>               (<code>str</code>, default:                   <code>'binning'</code> )           \u2013            <p>Method for spatial downsampling. Options are 'binning' (median binning) or 'sparse' (select sparse pixels). Default is \"binning\".</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.time_bin","title":"time_bin  <code>instance-attribute</code>","text":"<pre><code>time_bin = time_bin\n</code></pre>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.__init__","title":"__init__","text":"<pre><code>__init__(\n    sector: int = 1,\n    camera: int = 1,\n    ccd: int = 1,\n    img_bin: int = 16,\n    time_bin: int = 1,\n    downsize: str = \"binning\",\n)\n</code></pre>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.plot_dark_frame","title":"plot_dark_frame","text":"<pre><code>plot_dark_frame(mask_straps: bool = False)\n</code></pre> <p>Displays diagnostic plots of the darkest frame and associated masks.</p> <p>Shows the darkest FFI frame, the generated star mask, and optionally the strap mask.</p> <p>Parameters:</p> <ul> <li> <code>mask_straps</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also fetches and plots the strap mask. Requires the <code>_get_straps_mask</code> method to have been called or will call it. Default is False.</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.get_scatter_light_cube","title":"get_scatter_light_cube","text":"<pre><code>get_scatter_light_cube(\n    plot: bool = False,\n    mask_straps: bool = False,\n    frames: Optional[Tuple] = None,\n)\n</code></pre> <p>Computes the scattered light cube by processing FFIs.</p> <p>This method orchestrates the process of: 1. Identifying dark frames (<code>_get_dark_frame_idx</code>). 2. Creating a star mask (<code>_get_star_mask</code>). 3. Optionally creating a strap mask (<code>_get_straps_mask</code>). 4. Defining background pixels (excluding stars and optionally straps). 5. Calculating the static scene by median-combining dark frames (<code>_get_static_scene</code>). 6. Iterating through FFIs (all or a specified range):    - Fetching FFI data.    - Applying the background pixel mask (masking stars/straps).    - Subtracting the static scene.    - Downsampling the result using the specified <code>downsize</code> method ('binning' or 'sparse'). 7. Storing the final scattered light cube.</p> <p>Parameters:</p> <ul> <li> <code>plot</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, displays the diagnostic dark frame plots after mask creation. Default is False.</p> </li> <li> <code>mask_straps</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, masks out pixels corresponding to CCD straps in addition to stars. Default is False.</p> </li> <li> <code>frames</code>               (<code>Optional[Tuple]</code>, default:                   <code>None</code> )           \u2013            <p>Specifies a range of frame indices to process. Can be: - (N,): Process frames from 0 up to (but not including) N. - (start, stop): Process frames from index <code>start</code> up to <code>stop</code>. - (start, stop, step): Process frames from <code>start</code> to <code>stop</code> with <code>step</code>. If None, processes all frames. Default is None.</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.get_vector_maps","title":"get_vector_maps","text":"<pre><code>get_vector_maps(ang_size: bool = True)\n</code></pre> <p>Generates pixel-wise maps of Earth and Moon positions and sizes.</p> <p>Fetches spacecraft orientation and Earth/Moon position vectors using <code>tessvectors</code>. Then, for both Earth and Moon, it calls <code>_get_object_vectors</code> to compute 3D maps (time, row, col) representing the distance/angular size, altitude, and azimuth for each pixel in the downsampled grid over time. Also stores the boresight vectors for reference.</p> <p>Parameters:</p> <ul> <li> <code>ang_size</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the 'dist' maps and vectors represent angular size (degrees). If False, they represent physical distance ([m] for maps). Default is True.</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.save_data","title":"save_data","text":"<pre><code>save_data(\n    out_file: Optional[str] = None, save_maps: bool = False\n)\n</code></pre> <p>Saves the processed background data to a NumPy .npz file.</p> <p>Parameters:</p> <ul> <li> <code>out_file</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Path to the output .npz file. If None, a default filename is generated based on sector, camera, ccd, and binning factor, saved in the current directory. Default is None.</p> </li> <li> <code>save_maps</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, saves the detailed pixel-wise maps for Earth and Moon angles/distances alongside the scatter cube and boresight vectors. If False, saves only the scatter cube, time, cadence, and boresight vectors (smaller file size). Default is False.</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.animate_data","title":"animate_data","text":"<pre><code>animate_data(\n    data: str = \"sl\",\n    step: int = 10,\n    file_name: Optional[str] = None,\n    save: bool = False,\n)\n</code></pre> <p>Creates and optionally saves an animation of the processed data cubes.</p> <p>Generates an animation showing the time evolution of either the scattered light cube or one of the Earth/Moon angle/distance maps.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str</code>, default:                   <code>'sl'</code> )           \u2013            <p>Which data cube to animate. Options are: - 'sl': Scattered light cube (<code>scatter_cube</code>). - 'earth_alt': Earth altitude map (<code>earth_maps['alt']</code>). - 'earth_az': Earth azimuth map (<code>earth_maps['az']</code>). - 'earth_dist': Earth distance/angular size map (<code>earth_maps['dist']</code>). - 'moon_alt', 'moon_az', 'moon_dist': Corresponding Moon maps. Default is \"sl\".</p> </li> <li> <code>step</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Frame step for the animation (e.g., step=10 shows every 10th frame). Default is 10.</p> </li> <li> <code>file_name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Filename for saving the animation as a GIF. If None and <code>save</code> is True, a default filename is generated. Default is None.</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, saves the animation to the specified <code>file_name</code> (or default). If False, attempts to display the animation directly (requires IPython). Default is False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HTML or None</code>           \u2013            <p>If <code>save</code> is False and IPython is available, returns an HTML object for displaying the animation. Otherwise returns None.</p> </li> </ul>"},{"location":"tutorial_1/","title":"Tutorial 1","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre># basic imports\nimport os\nimport numpy as np\nfrom tess_backml import BackgroundCube\nfrom tess_backml.utils import pooling_2d\nimport matplotlib.pyplot as plt\n\n# increase animation frame limits\nimport matplotlib\nmatplotlib.rcParams[\"animation.embed_limit\"] = 2**128\n</pre> # basic imports import os import numpy as np from tess_backml import BackgroundCube from tess_backml.utils import pooling_2d import matplotlib.pyplot as plt  # increase animation frame limits import matplotlib matplotlib.rcParams[\"animation.embed_limit\"] = 2**128 In\u00a0[3]: Copied! <pre># define sector/camera/ccd\nsector = 2\ncamera = 1\nccd = 1\nbinsize = 16\n</pre> # define sector/camera/ccd sector = 2 camera = 1 ccd = 1 binsize = 16 <p>We initialize the object with a specific Sectopr/Camera/CCD, an image bin size, and a method for downsizing (default if 'binning')</p> In\u00a0[4]: Copied! <pre>bkg_data = BackgroundCube(\n    sector=sector, camera=camera, ccd=ccd, img_bin=binsize, downsize=\"binning\"\n)\nprint(bkg_data)\n</pre> bkg_data = BackgroundCube(     sector=sector, camera=camera, ccd=ccd, img_bin=binsize, downsize=\"binning\" ) print(bkg_data) <pre>TESS FFI Background object (Sector, Camera, CCD, N times): 2, 1, 1, 1245\n</pre> <p>Compute the binned scatter light cube which does:</p> <ul> <li>Finds the darkest frame in the sector to build a star mask and a saturated pixel mask</li> <li>Adds a strap mask</li> <li>Pulls the FFI flux data from the cloud</li> <li>Downsize the image by doing median 16x16 binning, masking out stars, straps, and saturated pixels</li> <li>The resulting scatter light cube has shape [nt, 128, 128]</li> </ul> In\u00a0[\u00a0]: Copied! <pre>bkg_data.get_scatter_light_cube(frames=None, mask_straps=True, plot=True)\n</pre> bkg_data.get_scatter_light_cube(frames=None, mask_straps=True, plot=True) <pre>Computing sector darkest frames...\n</pre> <pre>INFO:tess_backml:Computing sector darkest frames...\n</pre> <pre>Computing star mask...\n</pre> <pre>INFO:tess_backml:Computing star mask...\n</pre> <pre>Getting FFI flux cube...\n</pre> <pre>INFO:tess_backml:Getting FFI flux cube...\n</pre> <pre>Computing average static scene from darkes frames...\n</pre> <pre>INFO:tess_backml:Computing average static scene from darkes frames...\n</pre> <pre>Iterating frames:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 717/1245 [16:11&lt;11:24,  1.30s/it]</pre> <p>We can animate the scatter light cube for visualization</p> In\u00a0[6]: Copied! <pre>bkg_data.animate_data(data=\"sl\", save=False, step=10);\n</pre> bkg_data.animate_data(data=\"sl\", save=False, step=10); <pre>INFO:matplotlib.animation:Animation.save using &lt;class 'matplotlib.animation.HTMLWriter'&gt;\n</pre> Out[6]: Once Loop Reflect <p>Now we compute the Earth/Moon vector maps:</p> <ul> <li>We pull the Earth/Moon distance, azimuth, and elevation angles from the engineering files. This values a w.r.t. each camera's boresight and changes for each frame in the sector. Using trigonometric rules, we compute these values for each pixel in the downsized grid [nt, 128, 128].</li> <li>If <code>ang_size == True</code> then the Earth/Moon distances are changed to angular size.</li> </ul> In\u00a0[\u00a0]: Copied! <pre>bkg_data.get_vector_maps(ang_size=True)\n</pre> bkg_data.get_vector_maps(ang_size=True) <p>We can inspect these maps for a single frame</p> In\u00a0[\u00a0]: Copied! <pre>tdx = 500\n\nfig, ax = plt.subplots(2, 3, figsize=(9,6), sharex=True, sharey=True)\n\nfig.suptitle(\n    f\"Sector {sector} Camera {camera} CCD {ccd} | \"\n    f\"Frame {tdx} Time {bkg_data.time[tdx]:.3f}\"\n)\nax[0, 0].imshow(bkg_data.earth_maps[\"alt\"][tdx], origin=\"lower\")\nax[0, 1].imshow(bkg_data.earth_maps[\"az\"][tdx], origin=\"lower\")\nax[0, 2].imshow(bkg_data.earth_maps[\"dist\"][tdx], origin=\"lower\")\n\nax[0, 0].set_title(\"Earth Altitude Angle\")\nax[0, 1].set_title(\"Earth Azimuth Angle\")\nax[0, 2].set_title(\"Earth Angular Size\")\n\nax[1, 0].imshow(bkg_data.moon_maps[\"alt\"][tdx], origin=\"lower\")\nax[1, 1].imshow(bkg_data.moon_maps[\"az\"][tdx], origin=\"lower\")\nax[1, 2].imshow(bkg_data.moon_maps[\"dist\"][tdx], origin=\"lower\")\n\nax[1, 0].set_title(\"Moon Altitude Angle\")\nax[1, 1].set_title(\"Moon Azimuth Angle\")\nax[1, 2].set_title(\"Moon Angular Size\")\n\nax[0, 0].set_ylabel(\"Pixel Row\")\nax[1, 0].set_ylabel(\"Pixel Row\")\nax[1, 0].set_xlabel(\"Pixel Column\")\nax[1, 1].set_xlabel(\"Pixel Column\")\nax[1, 2].set_xlabel(\"Pixel Column\")\n\nplt.show()\n</pre> tdx = 500  fig, ax = plt.subplots(2, 3, figsize=(9,6), sharex=True, sharey=True)  fig.suptitle(     f\"Sector {sector} Camera {camera} CCD {ccd} | \"     f\"Frame {tdx} Time {bkg_data.time[tdx]:.3f}\" ) ax[0, 0].imshow(bkg_data.earth_maps[\"alt\"][tdx], origin=\"lower\") ax[0, 1].imshow(bkg_data.earth_maps[\"az\"][tdx], origin=\"lower\") ax[0, 2].imshow(bkg_data.earth_maps[\"dist\"][tdx], origin=\"lower\")  ax[0, 0].set_title(\"Earth Altitude Angle\") ax[0, 1].set_title(\"Earth Azimuth Angle\") ax[0, 2].set_title(\"Earth Angular Size\")  ax[1, 0].imshow(bkg_data.moon_maps[\"alt\"][tdx], origin=\"lower\") ax[1, 1].imshow(bkg_data.moon_maps[\"az\"][tdx], origin=\"lower\") ax[1, 2].imshow(bkg_data.moon_maps[\"dist\"][tdx], origin=\"lower\")  ax[1, 0].set_title(\"Moon Altitude Angle\") ax[1, 1].set_title(\"Moon Azimuth Angle\") ax[1, 2].set_title(\"Moon Angular Size\")  ax[0, 0].set_ylabel(\"Pixel Row\") ax[1, 0].set_ylabel(\"Pixel Row\") ax[1, 0].set_xlabel(\"Pixel Column\") ax[1, 1].set_xlabel(\"Pixel Column\") ax[1, 2].set_xlabel(\"Pixel Column\")  plt.show() In\u00a0[11]: Copied! <pre>bkg_data.nt, bkg_data.quality.sum()\n</pre> bkg_data.nt, bkg_data.quality.sum() Out[11]: <pre>(1245, 10)</pre> In\u00a0[10]: Copied! <pre>bkg_data.scatter_cube.shape, bkg_data.earth_vectors[\"dist\"].shape\n</pre> bkg_data.scatter_cube.shape, bkg_data.earth_vectors[\"dist\"].shape Out[10]: <pre>((1235, 128, 128), (1245,))</pre> <p>The computed scatter light, angle maps, and times values can be saved to disk as a <code>npz</code> file for future use.</p> In\u00a0[16]: Copied! <pre># save data to disk\nfname = f\"./data/ffi_cubes_bin{bkg_data.img_bin}_sector{sector:03}_{camera}-{ccd}_light.npz\"\nbkg_data.save_data(out_file=fname, save_maps=True)\n</pre> # save data to disk fname = f\"./data/ffi_cubes_bin{bkg_data.img_bin}_sector{sector:03}_{camera}-{ccd}_light.npz\" bkg_data.save_data(out_file=fname, save_maps=True) In\u00a0[17]: Copied! <pre>data = np.load(fname, )\ndata.items()\n</pre> data = np.load(fname, ) data.items() Out[17]: <pre>ItemsView(NpzFile './data/ffi_cubes_bin16_sector002_1-1_light.npz' with keys: scatter_cube, time, cadenceno, earth_alt_map, earth_az_map...)</pre> In\u00a0[15]: Copied! <pre>data[\"scatter_cube\"].shape, data[\"earth_alt_map\"].shape\n</pre> data[\"scatter_cube\"].shape, data[\"earth_alt_map\"].shape Out[15]: <pre>((1235, 128, 128), (1235, 128, 128))</pre> In\u00a0[21]: Copied! <pre>bar = plt.imshow(data[\"scatter_cube\"][1180], origin=\"lower\", vmin=0, vmax=120,)\nplt.colorbar(bar)\nplt.show()\n</pre> bar = plt.imshow(data[\"scatter_cube\"][1180], origin=\"lower\", vmin=0, vmax=120,) plt.colorbar(bar) plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorial_1/#tess-background-data","title":"TESS Background data\u00b6","text":"<p>This notebook shows how to use <code>BackgroundCube</code> to get TESS Full Frame Images (FFI) scatter light component and Earth/Moon angles as pixel maps for every camera/ccd in the instrument.</p> <p>This data could be used to train a machine learning model or used directly to correct the scatter light contribution in TESS cutouts.</p>"},{"location":"utils/","title":"<code>Utils</code>","text":""},{"location":"utils/#src.tess_backml.utils","title":"utils","text":""},{"location":"utils/#src.tess_backml.utils.pooling_2d","title":"pooling_2d","text":"<pre><code>pooling_2d(\n    input_array: ndarray,\n    kernel_size: int = 4,\n    stride: int = 4,\n    stat: Callable = nanmedian,\n) -&gt; ndarray\n</code></pre> <p>Performs 2D pooling on the input array.</p> <p>Parameters:</p> <ul> <li> <code>input_array</code>               (<code>ndarray</code>)           \u2013            <p>A 2D numpy array representing the input data.</p> </li> <li> <code>kernel_size</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The size of the pooling kernel (square), by default 4.</p> </li> <li> <code>stride</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The stride of the pooling operation, by default 4.</p> </li> <li> <code>stat</code>               (<code>Callable</code>, default:                   <code>nanmedian</code> )           \u2013            <p>The aggregation function to use for pooling (e.g., np.mean, np.max),  by default np.mean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A 2D numpy array representing the pooled output.</p> </li> </ul>"},{"location":"utils/#src.tess_backml.utils.plot_img","title":"plot_img","text":"<pre><code>plot_img(\n    img: ndarray,\n    scol_2d: Optional[ndarray] = None,\n    srow_2d: Optional[ndarray] = None,\n    plot_type: str = \"img\",\n    extent: Optional[Tuple] = None,\n    cbar: bool = True,\n    ax: Optional[Axes] = None,\n    title: str = \"\",\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    cnorm: Optional[Normalize] = None,\n    bar_label: str = \"Flux [e-/s]\",\n) -&gt; Axes\n</code></pre> <p>Plots an image with optional scatter points and colorbar.</p> <p>Parameters:</p> <ul> <li> <code>img</code>               (<code>ndarray</code>)           \u2013            <p>The 2D image data to be plotted.</p> </li> <li> <code>scol_2d</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>The column coordinates of scatter points, by default None.</p> </li> <li> <code>srow_2d</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>The row coordinates of scatter points, by default None.</p> </li> <li> <code>plot_type</code>               (<code>str</code>, default:                   <code>'img'</code> )           \u2013            <p>The type of plot to create ('img' or 'scatter'), by default \"img\".</p> </li> <li> <code>extent</code>               (<code>Optional[Tuple]</code>, default:                   <code>None</code> )           \u2013            <p>The extent of the image (left, right, bottom, top), by default None.</p> </li> <li> <code>cbar</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to display a colorbar, by default True.</p> </li> <li> <code>ax</code>               (<code>Optional[Axes]</code>, default:                   <code>None</code> )           \u2013            <p>The matplotlib Axes object to plot on, by default None. If None, a new figure and axes are created.</p> </li> <li> <code>title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the plot, by default \"\".</p> </li> <li> <code>vmin</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>The minimum value for the colormap, by default None.</p> </li> <li> <code>vmax</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>The maximum value for the colormap, by default None.</p> </li> <li> <code>cnorm</code>               (<code>Optional[Normalize]</code>, default:                   <code>None</code> )           \u2013            <p>Custom color normalization, by default None.</p> </li> <li> <code>bar_label</code>               (<code>str</code>, default:                   <code>'Flux [e-/s]'</code> )           \u2013            <p>The label for the colorbar, by default \"Flux [e-/s]\".\"</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>axes</code>           \u2013            </li> </ul>"},{"location":"utils/#src.tess_backml.utils.animate_cube","title":"animate_cube","text":"<pre><code>animate_cube(\n    cube: ndarray,\n    scol_2d: Optional[ndarray] = None,\n    srow_2d: Optional[ndarray] = None,\n    cadenceno: Optional[ndarray] = None,\n    time: Optional[ndarray] = None,\n    plot_type: str = \"img\",\n    extent: Optional[Tuple] = None,\n    interval: int = 200,\n    repeat_delay: int = 1000,\n    step: int = 1,\n    suptitle: str = \"\",\n    bar_label: str = \"Flux [e-/s]\",\n) -&gt; FuncAnimation\n</code></pre> <p>Animates a 3D data cube (time series of 2D images).</p> <p>Parameters:</p> <ul> <li> <code>cube</code>               (<code>ndarray</code>)           \u2013            <p>The 3D data cube to be animated (time, row, column).</p> </li> <li> <code>scol_2d</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>The column coordinates of scatter points, by default None.</p> </li> <li> <code>srow_2d</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>The row coordinates of scatter points, by default None.</p> </li> <li> <code>cadenceno</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>Cadence numbers corresponding to the time axis, by default None.</p> </li> <li> <code>time</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>Time values corresponding to the time axis, by default None.</p> </li> <li> <code>plot_type</code>               (<code>str</code>, default:                   <code>'img'</code> )           \u2013            <p>The type of plot to create ('img' or 'scatter'), by default \"img\".</p> </li> <li> <code>extent</code>               (<code>Optional[Tuple]</code>, default:                   <code>None</code> )           \u2013            <p>The extent of the images (left, right, bottom, top), by default None.</p> </li> <li> <code>interval</code>               (<code>int</code>, default:                   <code>200</code> )           \u2013            <p>Delay between frames in milliseconds, by default 200.</p> </li> <li> <code>repeat_delay</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Delay in milliseconds before repeating the animation, by default 1000.</p> </li> <li> <code>step</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Step size for frame selection, by default 1.</p> </li> <li> <code>suptitle</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Overall title for the animation figure, by default \"\".</p> </li> <li> <code>bar_label</code>               (<code>str</code>, default:                   <code>'Flux [e-/s]'</code> )           \u2013            <p>The label for the colorbar, by default \"Flux [e-/s]\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FuncAnimation</code>           \u2013            <p>The matplotlib FuncAnimation object.</p> </li> </ul>"}]}