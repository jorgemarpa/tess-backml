{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TESS Back ML","text":""},{"location":"#tldr","title":"TL,DR","text":"<p>This is a Python package to create specialized support data from the TESS Full Frame Image (FFI). With <code>tess-backml</code> you can isolate the scatter light (SL) contribution to FFIs and create downsize versions of the cubes for multiple uses:  - One use is to correct the SL signal in any FFI cutout by interpolating from a downsize version of the  cube.  - Another use is to create a machine learning training set with the SL cube and pixel maps of how the Earth and Moon angles change during sector observations. These two are the main contributions to the background signal.  - This package, also will enable ML model evaluation to correct the scatter light on the fly.</p>"},{"location":"#install","title":"Install","text":"<p>Install from this GitHub repository with</p> <pre><code>pip install git+https://github.com/jorgemarpa/tess-backml\n</code></pre> <p>PyPI will available shortly.</p>"},{"location":"#scatter-light-cube","title":"Scatter Light Cube","text":"<p>This animation shows the scattered light of a TESS FFI. The original 2048 x 2048 pixel  image was downsized to 128 x 128 pixels.</p> <p></p>"},{"location":"#angle-maps","title":"Angle Maps","text":"<p>The next figure shows the vector maps (distance, elevation, and azimuth angles) for  Earth and Moon with respect to the camera boresight. These maps have the same shape as the scatter light cube shown above.</p> <p></p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#create-a-sl-cube","title":"Create a SL Cube","text":"<p>From the original FFI cube size (~1200 times, 2k, 2k), we can extract and compute a downsize version of the SL by doing pixel binning and time binning. The resulting SL cube has typically shape (~300, 256, 256).</p> <p><pre><code>from tess_backml import BackgroundCube\n\nbkg_data = BackgroundCube(\n    sector=2, camera=1, ccd=1, img_bin=8, downsize=\"binning\"\n)\n\nbkg_data.get_scatter_light_cube(frames=None, mask_straps=True, plot=True, rolling=True, errors=True)\n\nbkg_data.bin_time_axis(bin_size=2.0)\n\nfname = f\"./data/ffi_sl_cube_sector{sector:03}_{camera}-{ccd}.fits\"\n_ = bkg_data.save_to_fits(out_file=fname, binned=True)\n</code></pre> This saves a FITS file that can be used later to correct any TPF. For more details see the SL Cube Tutorial.</p>"},{"location":"#correct-sl-in-tpf","title":"Correct SL in  TPF","text":"<p>Once we have a FITS file with the SL cube, we can use the corrector object to interpolate to the desired pixels and times, and correct the background SL.</p> <pre><code>import numpy as np\nimport lightkurve as lk\n\nfrom tesscube import TESSCube\nfrom tess_backml.corrector import ScatterLightCorrector\n\ntcube = TESSCube(sector=2, camera=1, ccd=1)\n# this is pseudo code\ntpf = tcube.get_tpf(&lt;TIC coords&gt;, shape=(25, 25))\n\n# Corrector object\nslcorr = ScatterLightCorrector(sector=2, camera=1, ccd=1, fname=fname)\n\n# pixel array for evaluation\nrow_eval = np.arange(tpf.row, tpf.row + tpf.shape[1])\ncol_eval = np.arange(tpf.column, tpf.column + tpf.shape[2])\n# time array for evaluation\ntime_eval = tpf.time.value + slcorr.btjd0\n\n# evaluate the SL model at given pixel/times\nsl_eval = slcorr.evaluate_scatterlight_model(\n    row_eval=row_eval, col_eval=col_eval, times=time_eval\n)\n\n# subtract the SL model\nflux_corr = tpf.flux - sl_eval * tpf.flux.unit\n</code></pre> <p>For more details see the Corrector Tutorial.</p>"},{"location":"#create-ml-training-set","title":"Create ML Training Set","text":"<p>To get the training data follow the steps:</p> <pre><code>from tess_backml import Background_Data\n\n# initialize the object for given sector/camera/ccd\n# will do 16x16 pixel binning\ntess_bkg = BackgroundCube(\n    sector=1, camera=1, ccd=1, img_bin=16, downsize=\"binning\"\n)\n\n# get the flux data from MAST/AWS, compute scatter light and downsize\ntess_bkg.get_scatter_light_cube(plot=False)\n# compute the vector maps for the Earth and Moon\ntess_bkg.get_vector_maps(ang_size=True)\n\n# make an animation of the scatter light cube\ntess_bkg.animate_data(data=\"sl\", save=False, step=10);\n\n# save data to disk\ntess_bkg.save_to_npz(save_maps=True)\n</code></pre> <p>Or you can run a Python script <code>build_dataset.py</code> in the terminal (plotting flag is optional and will add run time): <pre><code>usage: build_dataset.py [-h] [--sector SECTOR] [--camera CAMERA] [--ccd CCD] [--downsize DOWNSIZE] [--image-bin IMG_BIN] [--plot]\n                        [--out-dir OUT_DIR]\n\nBuild TESS FFI background dataset for a Sector/Camera/CCD.\n\noptions:\n  -h, --help           show this help message and exit\n  --sector SECTOR      TESS sector.\n  --camera CAMERA      TESS camera.\n  --ccd CCD            TESS camera.\n  --downsize DOWNSIZE  Method for downsizing the image, one of [sparse, binning].\n  --image-bin IMG_BIN  Image binning size, must divide 2048.\n  --plot               Plot target light curve.\n  --out-dir OUT_DIR    Outputh directory path where files and figures will be saved.\n</code></pre> For example <pre><code>python build_dataset.py --sector 3 --camera 1 --ccd 2 --image-bin 16 --downsize binning --plot\n</code></pre></p> <p>The script will save <code>npz</code> files with the following dictionary: <pre><code>\"scatter_cube\":   the data cube with the scatter light, shape [nt, 128, 128] depending on the binsize (16)\n\"time\":           time array in JD\n\"cadenceno\":      cadence number array\n\"earth_alt\":      Earth altitude angle from the camera boresight\n\"earth_az\":       Earth azimuth angle from the camera boresight\n\"earth_dist\":     Earth distance from the camera boresight\n\"moon_alt\":       Moon altitude angle from the camera boresight\n\"moon_az\":        Moon azimuth angle from the camera boresight\n\"moon_dist\":      Moon distance from the camera boresight\n\"earth_alt_map\":  Earth altitude angle map for every pixel, same shape as `scatter_cube`\n\"earth_az_map\":   Earth azimuth angle map for every pixel \n\"earth_dist_map\": Earth angular size map for every pixel \n\"moon_alt_map\":   Moon altitude angle map for every pixel \n\"moon_az_map\":    Moon azimuth angle map for every pixel \n\"moon_dist_map\":  Moon angular size map for every pixel \n</code></pre></p> <p>For more details see the Data Cubes Tutorial.</p>"},{"location":"bkg_data/","title":"<code>BackgroundCube</code>","text":""},{"location":"bkg_data/#src.tess_backml.BackgroundCube","title":"BackgroundCube","text":"<p>               Bases: <code>object</code></p> <p>Class for creating TESS Full Frame Image background cubes to train a deep learning model that predicts the scatter light.</p> <p>It uses <code>tesscube</code> to retrieve FFI cubes from MAST/AWS, does spatia binning to downsize the 2k x 2k image, e.g. to 128 x 128 pixels. It uses <code>tessvectors</code> to obtain Earth/Moon angles/distances with respect to each TESS camera and creates a pixel map for each object angle and distance with the same resolution as the downsize FFI cube.</p> <p>Package the data into local files or returns batches fot ML training.</p> <p>Parameters:</p> <ul> <li> <code>sector</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>TESS sector number. Must be between 1 and 100. Default is 1.</p> </li> <li> <code>camera</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>TESS camera number. Must be between 1 and 4. Default is 1.</p> </li> <li> <code>ccd</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>TESS CCD number. Must be between 1 and 4. Default is 1.</p> </li> <li> <code>img_bin</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>Binning factor for spatial downsampling of the FFI image. Must be a divisor of 2048. Default is 16. #</p> </li> <li> <code>downsize</code>               (<code>str</code>, default:                   <code>'binning'</code> )           \u2013            <p>Method for spatial downsampling. Options are 'binning' (median binning) or 'sparse' (select sparse pixels). Default is \"binning\".</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.__init__","title":"__init__","text":"<pre><code>__init__(\n    sector: int = 1,\n    camera: int = 1,\n    ccd: int = 1,\n    img_bin: int = 16,\n    downsize: str = \"binning\",\n)\n</code></pre>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.plot_dark_frame","title":"plot_dark_frame","text":"<pre><code>plot_dark_frame(mask_straps: bool = False)\n</code></pre> <p>Displays diagnostic plots of the darkest frame and associated masks.</p> <p>Shows the darkest FFI frame, the generated star mask, and optionally the strap mask.</p> <p>Parameters:</p> <ul> <li> <code>mask_straps</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also fetches and plots the strap mask. Requires the <code>_get_straps_mask</code> method to have been called or will call it. Default is False.</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.get_scatter_light_cube","title":"get_scatter_light_cube","text":"<pre><code>get_scatter_light_cube(\n    plot: bool = False,\n    mask_straps: bool = True,\n    frames: Optional[Tuple] = None,\n    rolling: bool = True,\n    errors: bool = True,\n)\n</code></pre> <p>Computes the scattered light cube by processing FFIs.</p> <p>This method orchestrates the process of: 1. Identifying dark frames (<code>_get_dark_frame_idx</code>). 2. Creating a star mask (<code>_get_star_mask</code>). 3. Optionally creating a strap mask (<code>_get_straps_mask</code>). 4. Defining background pixels (excluding stars and optionally straps). 5. Calculating the static scene by median-combining dark frames (<code>_get_static_scene</code>). 6. Iterating through FFIs (all or a specified range):    - Fetching FFI data.    - Applying the background pixel mask (masking stars/straps).    - Subtracting the static scene.    - Downsampling the result using the specified <code>downsize</code> method ('binning' or 'sparse'). 7. Storing the final scattered light cube.</p> <p>Parameters:</p> <ul> <li> <code>plot</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, displays the diagnostic dark frame plots after mask creation. Default is False.</p> </li> <li> <code>mask_straps</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, masks out pixels corresponding to CCD straps in addition to stars. Default is False.</p> </li> <li> <code>frames</code>               (<code>Optional[Tuple]</code>, default:                   <code>None</code> )           \u2013            <p>Specifies a range of frame indices to process. Can be: - (N,): Process frames from 0 up to (but not including) N. - (start, stop): Process frames from index <code>start</code> up to <code>stop</code>. - (start, stop, step): Process frames from <code>start</code> to <code>stop</code> with <code>step</code>. If None, processes all frames. Default is None.</p> </li> <li> <code>rolling</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, pooling downsizing will be done with an iterative rolling windown and stride  that will match the output desired shape, this will make the downsizing step slower. If False, pooling downsizing will use fixed window and stride.</p> </li> <li> <code>errors</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Retrieve and propagate errors</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.get_vector_maps","title":"get_vector_maps","text":"<pre><code>get_vector_maps(ang_size: bool = True)\n</code></pre> <p>Generates pixel-wise maps of Earth and Moon positions and sizes.</p> <p>Fetches spacecraft orientation and Earth/Moon position vectors using <code>tessvectors</code>. Then, for both Earth and Moon, it calls <code>_get_object_vectors</code> to compute 3D maps (time, row, col) representing the distance/angular size, altitude, and azimuth for each pixel in the downsampled grid over time. Also stores the boresight vectors for reference.</p> <p>Parameters:</p> <ul> <li> <code>ang_size</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the 'dist' maps and vectors represent angular size (degrees). If False, they represent physical distance ([m] for maps). Default is True.</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.bin_time_axis","title":"bin_time_axis","text":"<pre><code>bin_time_axis(bin_size: float = 2.5)\n</code></pre> <p>Performs temporal binning on the calculated data cubes and vectors.</p> <p>If <code>self.time_bin</code> is greater than 1, this method bins the time axis of <code>scatter_cube</code>, <code>time</code>, <code>cadenceno</code>, and all Earth/Moon vector maps and boresight vectors by taking the mean or median within each time bin.</p> <p>Parameters:</p> <ul> <li> <code>bin_size</code>               (<code>float</code>, default:                   <code>2.5</code> )           \u2013            <p>Bin size for time axis in units of hours (e.g. 2.5 hours).</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.save_to_fits","title":"save_to_fits","text":"<pre><code>save_to_fits(\n    out_file: Optional[str] = None, binned: bool = True\n)\n</code></pre> <p>Saves the downsize version of the scatter light cube as a FITS file similar to the MAST FFI cubes.</p> <p>Parameters:</p> <ul> <li> <code>out_file</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Path to the output .npz file. If None, a default filename is generated based on sector, camera, ccd, and binning factor, saved in the current directory. Default is None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>hdul</code> (              <code>HDUList object</code> )          \u2013            <p>Header unit list with data and metadata</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.save_to_npz","title":"save_to_npz","text":"<pre><code>save_to_npz(\n    out_file: Optional[str] = None, save_maps: bool = False\n)\n</code></pre> <p>Saves the processed background data to a NumPy .npz file.</p> <p>Parameters:</p> <ul> <li> <code>out_file</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Path to the output .npz file. If None, a default filename is generated based on sector, camera, ccd, and binning factor, saved in the current directory. Default is None.</p> </li> <li> <code>save_maps</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, saves the detailed pixel-wise maps for Earth and Moon angles/distances alongside the scatter cube and boresight vectors. If False, saves only the scatter cube, time, cadence, and boresight vectors (smaller file size). Default is False.</p> </li> </ul>"},{"location":"bkg_data/#src.tess_backml.BackgroundCube.animate_data","title":"animate_data","text":"<pre><code>animate_data(\n    data: str = \"sl\",\n    step: int = 10,\n    file_name: Optional[str] = None,\n    save: bool = False,\n)\n</code></pre> <p>Creates and optionally saves an animation of the processed data cubes.</p> <p>Generates an animation showing the time evolution of either the scattered light cube or one of the Earth/Moon angle/distance maps.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str</code>, default:                   <code>'sl'</code> )           \u2013            <p>Which data cube to animate. Options are: - 'sl': Scattered light cube (<code>scatter_cube</code>). - 'earth_alt': Earth altitude map (<code>earth_maps['alt']</code>). - 'earth_az': Earth azimuth map (<code>earth_maps['az']</code>). - 'earth_dist': Earth distance/angular size map (<code>earth_maps['dist']</code>). - 'moon_alt', 'moon_az', 'moon_dist': Corresponding Moon maps. Default is \"sl\".</p> </li> <li> <code>step</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Frame step for the animation (e.g., step=10 shows every 10th frame). Default is 10.</p> </li> <li> <code>file_name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Filename for saving the animation as a GIF. If None and <code>save</code> is True, a default filename is generated. Default is None.</p> </li> <li> <code>save</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, saves the animation to the specified <code>file_name</code> (or default). If False, attempts to display the animation directly (requires IPython). Default is False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HTML or None</code>           \u2013            <p>If <code>save</code> is False and IPython is available, returns an HTML object for displaying the animation. Otherwise returns None.</p> </li> </ul>"},{"location":"corrector/","title":"<code>ScatterLightCorrector</code>","text":""},{"location":"corrector/#src.tess_backml.ScatterLightCorrector","title":"ScatterLightCorrector","text":"<p>A class to handle scatter light correction for TESS data.</p> <p>Parameters:</p> <ul> <li> <code>sector</code>               (<code>int</code>)           \u2013            <p>The TESS sector number.</p> </li> <li> <code>camera</code>               (<code>int</code>)           \u2013            <p>The TESS camera number.</p> </li> <li> <code>ccd</code>               (<code>int</code>)           \u2013            <p>The TESS CCD number.</p> </li> <li> <code>fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Path to the FITS file containing the scatter light cube. If None, a default path is constructed based on the sector, camera, and CCD.</p> </li> </ul>"},{"location":"corrector/#src.tess_backml.ScatterLightCorrector.__init__","title":"__init__","text":"<pre><code>__init__(\n    sector: int,\n    camera: int,\n    ccd: int,\n    fname: Optional[str] = None,\n)\n</code></pre>"},{"location":"corrector/#src.tess_backml.ScatterLightCorrector.get_original_ffi_times","title":"get_original_ffi_times","text":"<pre><code>get_original_ffi_times() -&gt; ndarray\n</code></pre> <p>Retrieve the original frame times from FFIs.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of original frame times in JD format.</p> </li> </ul>"},{"location":"corrector/#src.tess_backml.ScatterLightCorrector.evaluate_scatterlight_model","title":"evaluate_scatterlight_model","text":"<pre><code>evaluate_scatterlight_model(\n    row_eval: ndarray,\n    col_eval: ndarray,\n    times: ndarray,\n    method: str = \"sl_cube\",\n) -&gt; Tuple[ndarray, ndarray]\n</code></pre> <p>Evaluate the scatter light model and compute SL fluxes at given pixels and times.</p> <p>Parameters:</p> <ul> <li> <code>row_eval</code>               (<code>ndarray</code>)           \u2013            <p>Array of row indices for evaluation.</p> </li> <li> <code>col_eval</code>               (<code>ndarray</code>)           \u2013            <p>Array of column indices for evaluation.</p> </li> <li> <code>times</code>               (<code>ndarray</code>)           \u2013            <p>Array of times for evaluation.</p> </li> <li> <code>method</code>               (<code>str</code>, default:                   <code>'sl_cube'</code> )           \u2013            <p>Method to use for evaluation. Options are \"sl_cube\" or \"nn\". Default is \"sl_cube\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>sl_flux</code> (              <code>ndarray</code> )          \u2013            <p>Scatter light flux at the specified pixels and times.</p> </li> <li> <code>sl_fluxerr</code> (              <code>ndarray</code> )          \u2013            <p>Scatter light flux error at the specified pixels and times.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the evaluation grid or times are out of bounds, or if an invalid method is specified.</p> </li> <li> <code>NotImplementedError</code>             \u2013            <p>If the \"nn\" method is selected (not implemented).</p> </li> </ul> Notes <p>(5/9/2025) The errors returned by the <code>sl_cube</code> method, which are computed by interpolating  a downsize version of the SL errors agregation done in <code>tess_backml.BacgroundData</code> is not a propper account for the real uncertainties of the evaluated SL flux, as the this does not account for the uncertainties of interpolation modeling.  A better interpolation model could be done by using a linear modeling as done in  PSFMachine. This option will be developed soon.</p>"},{"location":"t1_bkgcube/","title":"Data Cubes","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[1]: Copied! <pre># basic imports\nimport os\nimport numpy as np\nfrom tess_backml import BackgroundCube\nfrom tess_backml.utils import pooling_2d\nimport matplotlib.pyplot as plt\n\n# increase animation frame limits\nimport matplotlib\nmatplotlib.rcParams[\"animation.embed_limit\"] = 2**128\n</pre> # basic imports import os import numpy as np from tess_backml import BackgroundCube from tess_backml.utils import pooling_2d import matplotlib.pyplot as plt  # increase animation frame limits import matplotlib matplotlib.rcParams[\"animation.embed_limit\"] = 2**128 In\u00a0[2]: Copied! <pre># define sector/camera/ccd\nsector = 2\ncamera = 1\nccd = 1\nbinsize = 8\n</pre> # define sector/camera/ccd sector = 2 camera = 1 ccd = 1 binsize = 8 In\u00a0[3]: Copied! <pre>bkg_data = BackgroundCube(\n    sector=sector, camera=camera, ccd=ccd, img_bin=binsize, downsize=\"binning\"\n)\nprint(bkg_data)\n</pre> bkg_data = BackgroundCube(     sector=sector, camera=camera, ccd=ccd, img_bin=binsize, downsize=\"binning\" ) print(bkg_data) <pre>TESS FFI Background object (Sector, Camera, CCD, N times): 2, 1, 1, 1235\n</pre> In\u00a0[4]: Copied! <pre>bkg_data.get_scatter_light_cube(frames=None, mask_straps=True, plot=True, rolling=True)\n</pre> bkg_data.get_scatter_light_cube(frames=None, mask_straps=True, plot=True, rolling=True) <pre>INFO:tess_backml:Computing sector darkest frames...\nINFO:tess_backml:Computing star mask...\n</pre> <pre>INFO:tess_backml:Getting FFI flux cube...\nINFO:tess_backml:Computing average static scene from darkes frames...\n</pre> <pre>Iterating frames: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1245/1245 [1:25:30&lt;00:00,  4.12s/it]\n</pre> <p>We can animate the scatter light cube for visualization</p> In\u00a0[6]: Copied! <pre>bkg_data.animate_data(data=\"sl\", save=False, step=10);\n</pre> bkg_data.animate_data(data=\"sl\", save=False, step=10); <pre>INFO:matplotlib.animation:Animation.save using &lt;class 'matplotlib.animation.HTMLWriter'&gt;\n</pre> In\u00a0[7]: Copied! <pre>bkg_data.get_vector_maps(ang_size=True)\n</pre> bkg_data.get_vector_maps(ang_size=True) <pre>INFO:root:Retrieving TESSVector from: https://heasarc.gsfc.nasa.gov/docs/tess/data/TESSVectors/Vectors/FFI_Cadence/TessVectors_S002_C1_FFI.csv\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1245/1245 [00:02&lt;00:00, 471.70it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1245/1245 [00:02&lt;00:00, 465.24it/s]\n</pre> <p>We can inspect these maps for a single frame</p> In\u00a0[8]: Copied! <pre>tdx = 500\n\nfig, ax = plt.subplots(2, 3, figsize=(9,6), sharex=True, sharey=True)\n\nfig.suptitle(\n    f\"Sector {sector} Camera {camera} CCD {ccd} | \"\n    f\"Frame {tdx} Time {bkg_data.time[tdx]:.3f}\"\n)\nax[0, 0].imshow(bkg_data.earth_maps[\"alt\"][tdx], origin=\"lower\")\nax[0, 1].imshow(bkg_data.earth_maps[\"az\"][tdx], origin=\"lower\")\nax[0, 2].imshow(bkg_data.earth_maps[\"dist\"][tdx], origin=\"lower\")\n\nax[0, 0].set_title(\"Earth Altitude Angle\")\nax[0, 1].set_title(\"Earth Azimuth Angle\")\nax[0, 2].set_title(\"Earth Angular Size\")\n\nax[1, 0].imshow(bkg_data.moon_maps[\"alt\"][tdx], origin=\"lower\")\nax[1, 1].imshow(bkg_data.moon_maps[\"az\"][tdx], origin=\"lower\")\nax[1, 2].imshow(bkg_data.moon_maps[\"dist\"][tdx], origin=\"lower\")\n\nax[1, 0].set_title(\"Moon Altitude Angle\")\nax[1, 1].set_title(\"Moon Azimuth Angle\")\nax[1, 2].set_title(\"Moon Angular Size\")\n\nax[0, 0].set_ylabel(\"Pixel Row\")\nax[1, 0].set_ylabel(\"Pixel Row\")\nax[1, 0].set_xlabel(\"Pixel Column\")\nax[1, 1].set_xlabel(\"Pixel Column\")\nax[1, 2].set_xlabel(\"Pixel Column\")\n\nplt.show()\n</pre> tdx = 500  fig, ax = plt.subplots(2, 3, figsize=(9,6), sharex=True, sharey=True)  fig.suptitle(     f\"Sector {sector} Camera {camera} CCD {ccd} | \"     f\"Frame {tdx} Time {bkg_data.time[tdx]:.3f}\" ) ax[0, 0].imshow(bkg_data.earth_maps[\"alt\"][tdx], origin=\"lower\") ax[0, 1].imshow(bkg_data.earth_maps[\"az\"][tdx], origin=\"lower\") ax[0, 2].imshow(bkg_data.earth_maps[\"dist\"][tdx], origin=\"lower\")  ax[0, 0].set_title(\"Earth Altitude Angle\") ax[0, 1].set_title(\"Earth Azimuth Angle\") ax[0, 2].set_title(\"Earth Angular Size\")  ax[1, 0].imshow(bkg_data.moon_maps[\"alt\"][tdx], origin=\"lower\") ax[1, 1].imshow(bkg_data.moon_maps[\"az\"][tdx], origin=\"lower\") ax[1, 2].imshow(bkg_data.moon_maps[\"dist\"][tdx], origin=\"lower\")  ax[1, 0].set_title(\"Moon Altitude Angle\") ax[1, 1].set_title(\"Moon Azimuth Angle\") ax[1, 2].set_title(\"Moon Angular Size\")  ax[0, 0].set_ylabel(\"Pixel Row\") ax[1, 0].set_ylabel(\"Pixel Row\") ax[1, 0].set_xlabel(\"Pixel Column\") ax[1, 1].set_xlabel(\"Pixel Column\") ax[1, 2].set_xlabel(\"Pixel Column\")  plt.show() In\u00a0[9]: Copied! <pre>bkg_data.scatter_cube.shape, bkg_data.earth_maps[\"dist\"].shape\n</pre> bkg_data.scatter_cube.shape, bkg_data.earth_maps[\"dist\"].shape Out[9]: <pre>((1235, 256, 256), (1235, 256, 256))</pre> In\u00a0[11]: Copied! <pre>bkg_data.bin_time_axis(bin_size=2.0)\nbkg_data.time_bin.shape, bkg_data.scatter_cube_bin.shape, bkg_data.earth_maps_bin[\"dist\"].shape\n</pre> bkg_data.bin_time_axis(bin_size=2.0) bkg_data.time_bin.shape, bkg_data.scatter_cube_bin.shape, bkg_data.earth_maps_bin[\"dist\"].shape Out[11]: <pre>((312,), (312, 256, 256), (312, 256, 256))</pre> In\u00a0[\u00a0]: Copied! <pre># save data to disk\nfname = f\"./data/ffi_cubes_bin{bkg_data.img_bin}_sector{sector:03}_{camera}-{ccd}_light.npz\"\nprint(fname)\nbkg_data.save_to_npz(out_file=fname, save_maps=True)\n</pre> # save data to disk fname = f\"./data/ffi_cubes_bin{bkg_data.img_bin}_sector{sector:03}_{camera}-{ccd}_light.npz\" print(fname) bkg_data.save_to_npz(out_file=fname, save_maps=True) <pre>./data/ffi_cubes_bin8_sector002_1-1_light.npz\n</pre> In\u00a0[13]: Copied! <pre>data = np.load(fname, )\ndata.items()\n</pre> data = np.load(fname, ) data.items() Out[13]: <pre>ItemsView(NpzFile './data/ffi_cubes_bin8_sector002_1-1_light.npz' with keys: scatter_cube, time, cadenceno, earth_alt, earth_az...)</pre> In\u00a0[14]: Copied! <pre>data[\"scatter_cube\"].shape, data[\"earth_alt_map\"].shape\n</pre> data[\"scatter_cube\"].shape, data[\"earth_alt_map\"].shape Out[14]: <pre>((1235, 256, 256), (1235, 256, 256))</pre> In\u00a0[15]: Copied! <pre>bar = plt.imshow(data[\"scatter_cube\"][1180], origin=\"lower\", vmin=0, vmax=120,)\nplt.colorbar(bar)\nplt.show()\n</pre> bar = plt.imshow(data[\"scatter_cube\"][1180], origin=\"lower\", vmin=0, vmax=120,) plt.colorbar(bar) plt.show() <p>Or save only the scatter light cube in its binned version to <code>FITS</code> file.</p> In\u00a0[25]: Copied! <pre>fname = f\"./data/ffi_cubes_bin{bkg_data.img_bin}_sector{sector:03}_{camera}-{ccd}_light.fits\"\nprint(fname)\n_ = bkg_data.save_to_fits(out_file=fname, binned=True)\n</pre> fname = f\"./data/ffi_cubes_bin{bkg_data.img_bin}_sector{sector:03}_{camera}-{ccd}_light.fits\" print(fname) _ = bkg_data.save_to_fits(out_file=fname, binned=True) <pre>./data/ffi_cubes_bin8_sector002_1-1_light.fits\n</pre> In\u00a0[26]: Copied! <pre>from astropy.io import fits\n</pre> from astropy.io import fits In\u00a0[27]: Copied! <pre>hdul = fits.open(fname)\nhdul.info()\n</pre> hdul = fits.open(fname) hdul.info() <pre>Filename: ./data/ffi_cubes_bin8_sector002_1-1_light.fits\nNo.    Name      Ver    Type      Cards   Dimensions   Format\n  0  PRIMARY       1 PrimaryHDU      62   ()      \n  1  SCATTER LIGHT CUBE    1 ImageHDU        10   (2, 312, 256, 256)   float64   \n  2  PIXEL COUNTS    1 ImageHDU         8   (256, 256)   int64   \n  3  TIME          1 BinTableHDU     13   312R x 1C   [D]   \n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"t1_bkgcube/#tess-background-data","title":"TESS Background data\u00b6","text":"<p>This notebook shows how to use <code>BackgroundCube</code> to get TESS Full Frame Images (FFI) scatter light component and Earth/Moon angles as pixel maps for every camera/ccd in the instrument.</p> <p>This data could be used to train a machine learning model or used directly to correct the scatter light contribution in TESS cutouts.</p>"},{"location":"t1_bkgcube/#initialize","title":"Initialize\u00b6","text":"<p>We initialize the object with a specific Sectopr/Camera/CCD, an image bin size, and a method for downsizing (default if 'binning')</p>"},{"location":"t1_bkgcube/#get-flux-data","title":"Get Flux Data\u00b6","text":"<p>Compute the binned scatter light cube which does:</p> <ul> <li>Finds the darkest frame in the sector to build a star mask and a saturated pixel mask</li> <li>Adds a strap mask</li> <li>Pulls the FFI flux data from the cloud</li> <li>Downsize the image by doing median 8x8 (effective) binning, masking out stars, straps, and saturated pixels<ul> <li>If <code>rolling=True</code> downsizing is done with iterative rolling windows to get to the desired output shape, this will increase ~25% more the computing time, but will give more robust estimations around bright stars, saturated pixes, and straps.</li> </ul> </li> <li>The resulting scatter light cube has shape [nt, 256, 256]</li> </ul> <p>Note: this is the most time consuming step, most of the computing time is spend in I/O (~50-60% of each iteration). This can be speed up if we run this notebook in TIKE and take advantage of AWS, if that's the case, a typical Sector/Camera/CCD should take ~30-40 minutes, depending of load. In a local machine, it can take up to 1h depending on internet connection.</p>"},{"location":"t1_bkgcube/#compute-angle-maps","title":"Compute Angle Maps\u00b6","text":"<p>Now we compute the Earth/Moon vector maps:</p> <ul> <li>We pull the Earth/Moon distance, azimuth, and elevation angles from the engineering files. This values a w.r.t. each camera's boresight and changes for each frame in the sector. Using trigonometric rules, we compute these values for each pixel in the downsized grid [nt, 128, 128].</li> <li>If <code>ang_size == True</code> then the Earth/Moon distances are changed to angular size.</li> </ul>"},{"location":"t1_bkgcube/#time-binning","title":"Time binning\u00b6","text":"<p>We can do time binning to reduce size of the cubes and save memory/storage. The function <code>bkg_data.bin_time_axis()</code> takes the parameter <code>bin_size</code> as the size of the bin in hours. This creates new attributes (e.g. <code>bkg_data.time_bin</code> and <code>bkg_data.scatter_cube_bin</code>)</p>"},{"location":"t1_bkgcube/#save-data","title":"Save Data\u00b6","text":"<p>The computed scatter light, angle maps, and times values can be saved to disk as a <code>npz</code> file for future use. This will save the cubes/vectors with all times, no binning.</p>"},{"location":"t2_slcube/","title":"Scatter Light Cube","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre># basic imports\nimport os\nimport numpy as np\nfrom tess_backml import BackgroundCube\nimport matplotlib.pyplot as plt\n\n# increase animation frame limits\nimport matplotlib\nmatplotlib.rcParams[\"animation.embed_limit\"] = 2**128\n</pre> # basic imports import os import numpy as np from tess_backml import BackgroundCube import matplotlib.pyplot as plt  # increase animation frame limits import matplotlib matplotlib.rcParams[\"animation.embed_limit\"] = 2**128 In\u00a0[3]: Copied! <pre># define sector/camera/ccd\nsector = 2\ncamera = 1\nccd = 1\nbinsize = 8\n</pre> # define sector/camera/ccd sector = 2 camera = 1 ccd = 1 binsize = 8 In\u00a0[4]: Copied! <pre>bkg_data = BackgroundCube(\n    sector=sector, camera=camera, ccd=ccd, img_bin=binsize, downsize=\"binning\"\n)\nprint(bkg_data)\n</pre> bkg_data = BackgroundCube(     sector=sector, camera=camera, ccd=ccd, img_bin=binsize, downsize=\"binning\" ) print(bkg_data) <pre>TESS FFI Background object (Sector, Camera, CCD, N times): 2, 1, 1, 1235\n</pre> In\u00a0[5]: Copied! <pre>bkg_data.get_scatter_light_cube(frames=None, mask_straps=True, plot=True, rolling=True, errors=True)\n</pre> bkg_data.get_scatter_light_cube(frames=None, mask_straps=True, plot=True, rolling=True, errors=True) <pre>INFO:tess_backml:Computing sector darkest frames...\nINFO:tess_backml:Computing star mask...\n</pre> <pre>INFO:tess_backml:Getting FFI flux cube...\nINFO:tess_backml:Computing average static scene from darkes frames...\n</pre> <pre>Iterating frames: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1245/1245 [44:38&lt;00:00,  2.15s/it]\n</pre> <pre>89\nINFO:tess_backml:Filling nans with interpolation...\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1235/1235 [00:20&lt;00:00, 60.77it/s]\n</pre> <p>We can animate the scatter light cube for visualization</p> In\u00a0[6]: Copied! <pre>bkg_data.animate_data(data=\"sl\", save=False, step=10);\n</pre> bkg_data.animate_data(data=\"sl\", save=False, step=10); <pre>INFO:matplotlib.animation:Animation.save using &lt;class 'matplotlib.animation.HTMLWriter'&gt;\n</pre> In\u00a0[7]: Copied! <pre>bkg_data.bin_time_axis(bin_size=2.0)\nbkg_data.time_bin.shape, bkg_data.scatter_cube_bin.shape\n</pre> bkg_data.bin_time_axis(bin_size=2.0) bkg_data.time_bin.shape, bkg_data.scatter_cube_bin.shape Out[7]: <pre>((312,), (312, 256, 256))</pre> In\u00a0[\u00a0]: Copied! <pre>fname = f\"./data/ffi_sl_cube_sector{sector:03}_{camera}-{ccd}.fits\"\nprint(fname)\n_ = bkg_data.save_to_fits(out_file=fname, binned=True)\n</pre> fname = f\"./data/ffi_sl_cube_sector{sector:03}_{camera}-{ccd}.fits\" print(fname) _ = bkg_data.save_to_fits(out_file=fname, binned=True) <pre>./data/ffi_cubes_sector002_1-1_light.fits\n</pre> In\u00a0[9]: Copied! <pre>from astropy.io import fits\n</pre> from astropy.io import fits In\u00a0[10]: Copied! <pre>hdul = fits.open(fname)\nhdul.info()\n</pre> hdul = fits.open(fname) hdul.info() <pre>Filename: ./data/ffi_cubes_sector002_1-1_light.fits\nNo.    Name      Ver    Type      Cards   Dimensions   Format\n  0  PRIMARY       1 PrimaryHDU      62   ()      \n  1  SCATTER LIGHT CUBE    1 ImageHDU        10   (2, 312, 256, 256)   float64   \n  2  PIXEL COUNTS    1 ImageHDU         8   (256, 256)   int64   \n  3  TIME          1 BinTableHDU     13   312R x 1C   [D]   \n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"t2_slcube/#tess-background-data","title":"TESS Background data\u00b6","text":"<p>This notebook shows how to use <code>BackgroundCube</code> to get TESS Full Frame Images (FFI) scatter light component for every camera/ccd in the instrument.</p> <p>This data could be used to correct the scatter light contribution in TESS FFI cutouts.</p>"},{"location":"t2_slcube/#initialize","title":"Initialize\u00b6","text":"<p>We initialize the object with a specific Sectopr/Camera/CCD, an image bin size, and a method for downsizing (default if 'binning')</p>"},{"location":"t2_slcube/#get-flux-data","title":"Get Flux Data\u00b6","text":"<p>Compute the binned scatter light cube which does:</p> <ul> <li>Finds the darkest frame in the sector to build a star mask and a saturated pixel mask</li> <li>Adds a strap mask</li> <li>Pulls the FFI flux data from the cloud</li> <li>Downsize the image by doing median 8x8 (effective) binning, masking out stars, straps, and saturated pixels<ul> <li>If <code>rolling=True</code> downsizing is done with iterative rolling windows to get to the desired output shape, this will increase ~25% more the computing time, but will give more robust estimations around bright stars, saturated pixes, and straps.</li> </ul> </li> <li>The resulting scatter light cube has shape [nt, 256, 256]</li> </ul> <p>Note: this is the most time consuming step, most of the computing time is spend in I/O (~50-60% of each iteration). This can be speed up if we run this notebook in TIKE and take advantage of AWS, if that's the case, a typical Sector/Camera/CCD should take ~30-40 minutes, depending of load. In a local machine, it can take up to 1h depending on internet connection.</p>"},{"location":"t2_slcube/#time-binning","title":"Time binning\u00b6","text":"<p>We can do time binning to reduce size of the cubes and save memory/storage. The function <code>bkg_data.bin_time_axis()</code> takes the parameter <code>bin_size</code> as the size of the bin in hours. This creates new attributes (e.g. <code>bkg_data.time_bin</code> and <code>bkg_data.scatter_cube_bin</code>)</p>"},{"location":"t2_slcube/#save-data","title":"Save Data\u00b6","text":"<p>Save only the scatter light cube in its binned version to a <code>FITS</code> file.</p>"},{"location":"t3_slcorrector/","title":"Scatter Light Corrector","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[12]: Copied! <pre>import numpy as np\nimport lightkurve as lk\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport astropy.units as u\n\nfrom tesscube import TESSCube\nfrom tqdm import tqdm\nfrom astropy.stats import median_absolute_deviation as MAD\nfrom astropy.io import fits\nfrom astropy.coordinates import SkyCoord\nfrom scipy.ndimage import label\n\nfrom tess_backml.corrector import ScatterLightCorrector\n</pre> import numpy as np import lightkurve as lk import matplotlib.pyplot as plt import pandas as pd import astropy.units as u  from tesscube import TESSCube from tqdm import tqdm from astropy.stats import median_absolute_deviation as MAD from astropy.io import fits from astropy.coordinates import SkyCoord from scipy.ndimage import label  from tess_backml.corrector import ScatterLightCorrector In\u00a0[3]: Copied! <pre># define sector/camera/ccd\nsector = 2\ncamera = 1\nccd = 1\n# CCD edges\nrmin, rmax = 0, 2048\ncmin, cmax = 45, 2093\n</pre> # define sector/camera/ccd sector = 2 camera = 1 ccd = 1 # CCD edges rmin, rmax = 0, 2048 cmin, cmax = 45, 2093 In\u00a0[4]: Copied! <pre># help function to do segmentation and labeling in a star mask\ndef label_mask_segments(mask: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Labels connected segments in a 2D boolean mask.\n\n    Parameters\n    ----------\n    mask : np.ndarray\n        A 2D NumPy array of boolean values where True\n        indicates a foreground pixel and False indicates\n        a background pixel.\n\n    Returns\n    -------\n    labeled_array: np.ndarray\n        A 2D NumPy array of the same shape as the input mask,\n        where each connected segment of True values is assigned\n        a unique positive integer label. Background pixels (False)\n        will have a label of 0.\n    \"\"\"\n    if not isinstance(mask, np.ndarray):\n        raise TypeError(\"Input mask must be a NumPy array.\")\n    if mask.ndim != 2:\n        raise ValueError(\"Input mask must be a 2D array.\")\n    if mask.dtype != bool:\n        # If the mask is not boolean, convert it.\n        # This handles cases where the mask might be 0s and 1s.\n        mask = mask.astype(bool)\n\n    labeled_array, num_features = label(mask)\n\n    print(f\"Found {num_features} distinct segments.\")\n    return labeled_array\n</pre> # help function to do segmentation and labeling in a star mask def label_mask_segments(mask: np.ndarray) -&gt; np.ndarray:     \"\"\"     Labels connected segments in a 2D boolean mask.      Parameters     ----------     mask : np.ndarray         A 2D NumPy array of boolean values where True         indicates a foreground pixel and False indicates         a background pixel.      Returns     -------     labeled_array: np.ndarray         A 2D NumPy array of the same shape as the input mask,         where each connected segment of True values is assigned         a unique positive integer label. Background pixels (False)         will have a label of 0.     \"\"\"     if not isinstance(mask, np.ndarray):         raise TypeError(\"Input mask must be a NumPy array.\")     if mask.ndim != 2:         raise ValueError(\"Input mask must be a 2D array.\")     if mask.dtype != bool:         # If the mask is not boolean, convert it.         # This handles cases where the mask might be 0s and 1s.         mask = mask.astype(bool)      labeled_array, num_features = label(mask)      print(f\"Found {num_features} distinct segments.\")     return labeled_array In\u00a0[5]: Copied! <pre>tics = pd.read_csv(\n    f\"./data/all_targets_S{sector:03}_v1.csv\", skiprows=5\n).query(f\"Camera == {camera} and CCD == {ccd}\").reset_index()\ntics\n</pre> tics = pd.read_csv(     f\"./data/all_targets_S{sector:03}_v1.csv\", skiprows=5 ).query(f\"Camera == {camera} and CCD == {ccd}\").reset_index() tics Out[5]: index TICID Camera CCD Tmag RA Dec 0 298 9156895 1 1 10.20 351.6895 -23.7569 1 302 9163365 1 1 9.68 351.8080 -23.5895 2 303 9163461 1 1 9.53 351.8870 -23.8036 3 304 9163481 1 1 9.41 351.8548 -23.7171 4 567 12881069 1 1 10.21 345.2380 -26.1739 ... ... ... ... ... ... ... ... 747 15212 393949845 1 1 10.10 344.7404 -36.4572 748 15213 393949920 1 1 10.83 344.7548 -36.1248 749 15214 393950079 1 1 5.75 345.6416 -36.4207 750 15968 471012252 1 1 10.16 346.9489 -27.9071 751 15993 471015557 1 1 5.46 346.4668 -35.8531 <p>752 rows \u00d7 7 columns</p> <p>We'll use <code>tesscube</code> to extract a TPF</p> In\u00a0[6]: Copied! <pre>tcube = TESSCube(sector=sector, camera=camera, ccd=ccd)\n</pre> tcube = TESSCube(sector=sector, camera=camera, ccd=ccd) In\u00a0[7]: Copied! <pre># TIC example\nk = 748\nprint(tics.TICID[k])\n# make a TPF around the coordinates\ncoord = SkyCoord(ra=tics.RA[k] * u.deg, dec=tics.Dec[k] * u.deg)\nhdul = tcube.get_tpf(coord, shape=(25, 25))\n# remove frames with coarse point\ntpf = lk.TessTargetPixelFile(hdul, quality_bitmask=(4))\ntpf.plot();\n</pre> # TIC example k = 748 print(tics.TICID[k]) # make a TPF around the coordinates coord = SkyCoord(ra=tics.RA[k] * u.deg, dec=tics.Dec[k] * u.deg) hdul = tcube.get_tpf(coord, shape=(25, 25)) # remove frames with coarse point tpf = lk.TessTargetPixelFile(hdul, quality_bitmask=(4)) tpf.plot(); <pre>393949920\n</pre> <pre>1% (10/1245) of the cadences will be ignored due to the quality mask (quality_bitmask=4).\n</pre> <pre>INFO:lightkurve.utils:1% (10/1245) of the cadences will be ignored due to the quality mask (quality_bitmask=4).\n</pre> In\u00a0[8]: Copied! <pre>fname = f\"./data/ffi_sl_cube_sector{sector:03}_{camera}-{ccd}.fits\"\nhdul = fits.open(fname)\nhdul.info()\n</pre> fname = f\"./data/ffi_sl_cube_sector{sector:03}_{camera}-{ccd}.fits\" hdul = fits.open(fname) hdul.info() <pre>Filename: ./data/ffi_sl_cube_sector002_1-1.fits\nNo.    Name      Ver    Type      Cards   Dimensions   Format\n  0  PRIMARY       1 PrimaryHDU      62   ()      \n  1  SCATTER LIGHT CUBE    1 ImageHDU        10   (2, 312, 256, 256)   float32   \n  2  PIXEL COUNTS    1 ImageHDU         8   (256, 256)   int64   \n  3  TIME          1 BinTableHDU     13   312R x 1C   [D]   \n</pre> <p>Initialize the corrector object</p> In\u00a0[9]: Copied! <pre>slcorr = ScatterLightCorrector(sector=sector, camera=camera, ccd=ccd, fname=fname)\nslcorr\n</pre> slcorr = ScatterLightCorrector(sector=sector, camera=camera, ccd=ccd, fname=fname) slcorr Out[9]: <pre>TESS FFI SL Corrector (Sector, Camera, CCD): 2, 1, 1</pre> <p>The SLCorrector needs the row and column pixels that will be evaluated and the times of observations. We'll create these using the TPF</p> In\u00a0[10]: Copied! <pre># pixel array for evaluation\nrow_eval = np.arange(tpf.row, tpf.row + tpf.shape[1])\ncol_eval = np.arange(tpf.column, tpf.column + tpf.shape[2])\n# time array for evaluation\ntime_eval = tpf.time.value + slcorr.btjd0\n# evaluate the SL model at given pixel/times\nsl_eval = slcorr.evaluate_scatterlight_model(\n    row_eval=row_eval, col_eval=col_eval, times=time_eval\n)\n</pre> # pixel array for evaluation row_eval = np.arange(tpf.row, tpf.row + tpf.shape[1]) col_eval = np.arange(tpf.column, tpf.column + tpf.shape[2]) # time array for evaluation time_eval = tpf.time.value + slcorr.btjd0 # evaluate the SL model at given pixel/times sl_eval = slcorr.evaluate_scatterlight_model(     row_eval=row_eval, col_eval=col_eval, times=time_eval ) <pre>INFO:tess_backml:time index range [0:312]\nINFO:tess_backml:[row,col] range  [48:54, 19:26]\n</pre> <pre>Time interp: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 42/42 [00:00&lt;00:00, 7977.57it/s]\nPixel interp: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1235/1235 [00:00&lt;00:00, 16359.68it/s]\n</pre> <p>Now, we create a mask with every star in the TPF to do aperture photometry.</p> In\u00a0[13]: Copied! <pre>threshold = 3\n# median image\nmedian_image = np.nanmedian(tpf.flux, axis=0)\nvals = median_image[np.isfinite(median_image)].flatten()\n# compute cut using MAD and assuming gaussianity\nmad_cut = (1.4826 * MAD(vals) * threshold) + np.nanmedian(median_image)\n# Create a mask containing the pixels above the threshold flux\nthreshold_mask = np.nan_to_num(median_image) &gt;= mad_cut\n# segmentation of stars and background \nstars_mask = label_mask_segments(threshold_mask)\n</pre> threshold = 3 # median image median_image = np.nanmedian(tpf.flux, axis=0) vals = median_image[np.isfinite(median_image)].flatten() # compute cut using MAD and assuming gaussianity mad_cut = (1.4826 * MAD(vals) * threshold) + np.nanmedian(median_image) # Create a mask containing the pixels above the threshold flux threshold_mask = np.nan_to_num(median_image) &gt;= mad_cut # segmentation of stars and background  stars_mask = label_mask_segments(threshold_mask) <pre>Found 9 distinct segments.\n</pre> In\u00a0[14]: Copied! <pre>for star in np.unique(stars_mask):\n    tpf.plot(cadenceno=100, aperture_mask=stars_mask == star)\n    plt.show()\n    raw_lc = tpf.extract_aperture_photometry(aperture_mask=stars_mask == star)\n    corr_lc = np.nansum((tpf.flux - sl_eval * tpf.flux.unit)[:, stars_mask == star], axis=1)\n\n    ax = raw_lc.plot(label=\"Raw\", lw=1, c=\"gray\")\n    ax.plot(raw_lc.time.value, corr_lc, label=\"SL(8) corrected\", zorder=-5000, lw=1, c=\"tab:blue\")\n    ax.set_title(\"Background\" if star == 0 else f\"Star {star}\")\n    plt.legend()\n    plt.show()\n    # break\n</pre> for star in np.unique(stars_mask):     tpf.plot(cadenceno=100, aperture_mask=stars_mask == star)     plt.show()     raw_lc = tpf.extract_aperture_photometry(aperture_mask=stars_mask == star)     corr_lc = np.nansum((tpf.flux - sl_eval * tpf.flux.unit)[:, stars_mask == star], axis=1)      ax = raw_lc.plot(label=\"Raw\", lw=1, c=\"gray\")     ax.plot(raw_lc.time.value, corr_lc, label=\"SL(8) corrected\", zorder=-5000, lw=1, c=\"tab:blue\")     ax.set_title(\"Background\" if star == 0 else f\"Star {star}\")     plt.legend()     plt.show()     # break <p>Wooow!! Those corrected LCs look very flat, the strong SL signal at the end of each TESS orbit is corrected, for all the stars in this TPF. Let's check out how does this look for \"empty\" apertures in the background. We'll create random apertures in the background.</p> In\u00a0[15]: Copied! <pre># get 10 random positions in the background\ntpf_rows, tpf_cols = np.mgrid[tpf.row: tpf.row + tpf.shape[1], tpf.column: tpf.column + tpf.shape[2]]\nbkg_rows = tpf_rows[stars_mask == 0]\nbkg_cols = tpf_cols[stars_mask == 0]\nr0, c0 = np.random.choice(bkg_rows, size=10), np.random.choice(bkg_cols, size=10)\n</pre> # get 10 random positions in the background tpf_rows, tpf_cols = np.mgrid[tpf.row: tpf.row + tpf.shape[1], tpf.column: tpf.column + tpf.shape[2]] bkg_rows = tpf_rows[stars_mask == 0] bkg_cols = tpf_cols[stars_mask == 0] r0, c0 = np.random.choice(bkg_rows, size=10), np.random.choice(bkg_cols, size=10) In\u00a0[16]: Copied! <pre># iterate every position and make a 2.5 rad aperture without star signal\nrad = 2.5\nfor r, c in zip(r0, c0):\n    # aperture mask\n    empty_ap = (np.sqrt((r - tpf_rows)**2 + (c - tpf_cols)**2) &lt; rad) &amp; (stars_mask == 0)\n    tpf.plot(cadenceno=100, aperture_mask=empty_ap)\n    plt.show()\n\n    # raw LC\n    raw_lc = tpf.extract_aperture_photometry(aperture_mask=empty_ap)\n    # corrected LC\n    corr_lc = np.nansum((tpf.flux - sl_eval * tpf.flux.unit)[:, empty_ap], axis=1)\n\n    ax = raw_lc.plot(label=\"Raw\", lw=1, c=\"gray\")\n    ax.plot(raw_lc.time.value, corr_lc, label=\"SL(8) corrected\", zorder=-5000, lw=1, c=\"tab:blue\")\n    ax.set_title(\"Background\" if star == 0 else f\"Empty {star}\")\n    plt.legend()\n    plt.show()\n    # break\n</pre> # iterate every position and make a 2.5 rad aperture without star signal rad = 2.5 for r, c in zip(r0, c0):     # aperture mask     empty_ap = (np.sqrt((r - tpf_rows)**2 + (c - tpf_cols)**2) &lt; rad) &amp; (stars_mask == 0)     tpf.plot(cadenceno=100, aperture_mask=empty_ap)     plt.show()      # raw LC     raw_lc = tpf.extract_aperture_photometry(aperture_mask=empty_ap)     # corrected LC     corr_lc = np.nansum((tpf.flux - sl_eval * tpf.flux.unit)[:, empty_ap], axis=1)      ax = raw_lc.plot(label=\"Raw\", lw=1, c=\"gray\")     ax.plot(raw_lc.time.value, corr_lc, label=\"SL(8) corrected\", zorder=-5000, lw=1, c=\"tab:blue\")     ax.set_title(\"Background\" if star == 0 else f\"Empty {star}\")     plt.legend()     plt.show()     # break In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"t3_slcorrector/#test-scatterlightcorrector-class","title":"Test ScatterLightCorrector Class\u00b6","text":"<p>This notebook shows how to use <code>ScatterLightCorrector</code> class to access the scatter light (SL) cube files and evaluate them in a given pixel grid and cadences using to correct the SL background signal of TPFs.</p>"},{"location":"t3_slcorrector/#get-tpfs","title":"Get TPFs\u00b6","text":"<p>We'll use star examples for this Sector/Camera/CCD, here's the TIC catalog</p>"},{"location":"t3_slcorrector/#corrector","title":"Corrector\u00b6","text":"<p>The class internally reads the FITS file that has the downsize version of the SL cube computed from the FFIs. The FITS fila also has the necessary metadata to describe the downsampling function, binsizes, etc. We can inspect the FITS file:</p>"},{"location":"t3_slcorrector/#lc-comparison","title":"LC comparison\u00b6","text":"<p>Let's compare the raw light curve vs the SL corrected ones for the background and a set of stars in the TPF</p>"},{"location":"utils/","title":"<code>Utils</code>","text":""},{"location":"utils/#src.tess_backml.utils","title":"utils","text":""},{"location":"utils/#src.tess_backml.utils.pooling_2d","title":"pooling_2d","text":"<pre><code>pooling_2d(\n    input_array: ndarray,\n    kernel_size: int = 4,\n    stride: int = 4,\n    padding: Union[int, Tuple[int, int]] = 0,\n    stat: Callable = nanmedian,\n) -&gt; ndarray\n</code></pre> <p>Performs 2D pooling on the input array with optional zero padding.</p> <p>Parameters:</p> <ul> <li> <code>input_array</code>               (<code>ndarray</code>)           \u2013            <p>A 2D numpy array representing the input data.</p> </li> <li> <code>kernel_size</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The size of the pooling kernel (square), by default 4. Must be positive.</p> </li> <li> <code>stride</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The stride of the pooling operation, by default 4. Must be positive.</p> </li> <li> <code>padding</code>               (<code>Union[int, Tuple[int, int]]</code>, default:                   <code>0</code> )           \u2013            <p>Padding to be added to the input array before pooling. - If an int <code>p</code>: applies symmetric padding of <code>p</code> zeros.   <code>p</code> rows of zeros are added to the top and <code>p</code> to the bottom.   <code>p</code> columns of zeros are added to the left and <code>p</code> to the right. - If a tuple <code>(p_h, p_w)</code>: applies <code>p_h</code> rows of zeros to the top and <code>p_h</code> to the bottom,   and <code>p_w</code> columns of zeros to the left and <code>p_w</code> to the right. Padding values must be non-negative. Default is 0 (no padding).</p> </li> <li> <code>stat</code>               (<code>Callable</code>, default:                   <code>nanmedian</code> )           \u2013            <p>The aggregation function to use for pooling (e.g., np.mean, np.max, np.nanmedian), by default np.nanmedian.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A 2D numpy array representing the pooled output.</p> </li> </ul>"},{"location":"utils/#src.tess_backml.utils.fill_nans_interp","title":"fill_nans_interp","text":"<pre><code>fill_nans_interp(cube: ndarray, deg: int = 3) -&gt; ndarray\n</code></pre> <p>Replace nan values in a data cube using plynomial interpolation</p> <p>Parameters:</p> <ul> <li> <code>cube</code>               (<code>ndarray</code>)           \u2013            <p>Data cube with nan values to be interpolated</p> </li> <li> <code>deg</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Degree of polynomial, defualt is 3.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Interpolated data cube without nan values</p> </li> </ul>"},{"location":"utils/#src.tess_backml.utils.plot_img","title":"plot_img","text":"<pre><code>plot_img(\n    img: ndarray,\n    scol_2d: Optional[ndarray] = None,\n    srow_2d: Optional[ndarray] = None,\n    plot_type: str = \"img\",\n    extent: Optional[Tuple] = None,\n    cbar: bool = True,\n    ax: Optional[Axes] = None,\n    title: str = \"\",\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    cnorm: Optional[Normalize] = None,\n    bar_label: str = \"Flux [e-/s]\",\n) -&gt; Axes\n</code></pre> <p>Plots an image with optional scatter points and colorbar.</p> <p>Parameters:</p> <ul> <li> <code>img</code>               (<code>ndarray</code>)           \u2013            <p>The 2D image data to be plotted.</p> </li> <li> <code>scol_2d</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>The column coordinates of scatter points, by default None.</p> </li> <li> <code>srow_2d</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>The row coordinates of scatter points, by default None.</p> </li> <li> <code>plot_type</code>               (<code>str</code>, default:                   <code>'img'</code> )           \u2013            <p>The type of plot to create ('img' or 'scatter'), by default \"img\".</p> </li> <li> <code>extent</code>               (<code>Optional[Tuple]</code>, default:                   <code>None</code> )           \u2013            <p>The extent of the image (left, right, bottom, top), by default None.</p> </li> <li> <code>cbar</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to display a colorbar, by default True.</p> </li> <li> <code>ax</code>               (<code>Optional[Axes]</code>, default:                   <code>None</code> )           \u2013            <p>The matplotlib Axes object to plot on, by default None. If None, a new figure and axes are created.</p> </li> <li> <code>title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the plot, by default \"\".</p> </li> <li> <code>vmin</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>The minimum value for the colormap, by default None.</p> </li> <li> <code>vmax</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>The maximum value for the colormap, by default None.</p> </li> <li> <code>cnorm</code>               (<code>Optional[Normalize]</code>, default:                   <code>None</code> )           \u2013            <p>Custom color normalization, by default None.</p> </li> <li> <code>bar_label</code>               (<code>str</code>, default:                   <code>'Flux [e-/s]'</code> )           \u2013            <p>The label for the colorbar, by default \"Flux [e-/s]\".\"</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>axes</code>           \u2013            </li> </ul>"},{"location":"utils/#src.tess_backml.utils.animate_cube","title":"animate_cube","text":"<pre><code>animate_cube(\n    cube: ndarray,\n    scol_2d: Optional[ndarray] = None,\n    srow_2d: Optional[ndarray] = None,\n    cadenceno: Optional[ndarray] = None,\n    time: Optional[ndarray] = None,\n    plot_type: str = \"img\",\n    extent: Optional[Tuple] = None,\n    interval: int = 200,\n    repeat_delay: int = 1000,\n    step: int = 1,\n    suptitle: str = \"\",\n    bar_label: str = \"Flux [e-/s]\",\n) -&gt; FuncAnimation\n</code></pre> <p>Animates a 3D data cube (time series of 2D images).</p> <p>Parameters:</p> <ul> <li> <code>cube</code>               (<code>ndarray</code>)           \u2013            <p>The 3D data cube to be animated (time, row, column).</p> </li> <li> <code>scol_2d</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>The column coordinates of scatter points, by default None.</p> </li> <li> <code>srow_2d</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>The row coordinates of scatter points, by default None.</p> </li> <li> <code>cadenceno</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>Cadence numbers corresponding to the time axis, by default None.</p> </li> <li> <code>time</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>Time values corresponding to the time axis, by default None.</p> </li> <li> <code>plot_type</code>               (<code>str</code>, default:                   <code>'img'</code> )           \u2013            <p>The type of plot to create ('img' or 'scatter'), by default \"img\".</p> </li> <li> <code>extent</code>               (<code>Optional[Tuple]</code>, default:                   <code>None</code> )           \u2013            <p>The extent of the images (left, right, bottom, top), by default None.</p> </li> <li> <code>interval</code>               (<code>int</code>, default:                   <code>200</code> )           \u2013            <p>Delay between frames in milliseconds, by default 200.</p> </li> <li> <code>repeat_delay</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Delay in milliseconds before repeating the animation, by default 1000.</p> </li> <li> <code>step</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Step size for frame selection, by default 1.</p> </li> <li> <code>suptitle</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Overall title for the animation figure, by default \"\".</p> </li> <li> <code>bar_label</code>               (<code>str</code>, default:                   <code>'Flux [e-/s]'</code> )           \u2013            <p>The label for the colorbar, by default \"Flux [e-/s]\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FuncAnimation</code>           \u2013            <p>The matplotlib FuncAnimation object.</p> </li> </ul>"},{"location":"utils/#src.tess_backml.utils.int_to_binary_array","title":"int_to_binary_array","text":"<pre><code>int_to_binary_array(integer: int, num_bits: int) -&gt; ndarray\n</code></pre> <p>Converts a non-negative integer to its binary representation as a NumPy array.</p> <p>Parameters:</p> <ul> <li> <code>integer</code>               (<code>int</code>)           \u2013            <p>The non-negative integer to convert.</p> </li> <li> <code>num_bits</code>               (<code>int</code>)           \u2013            <p>The desired number of bits in the output binary representation. The binary string will be left-padded with zeros if necessary. Must be greater than zero.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A NumPy array of dtype uint8 representing the binary digits (0 or 1), with the most significant bit first. The length of the array is <code>num_bits</code>.</p> </li> </ul>"},{"location":"utils/#src.tess_backml.utils.has_bit","title":"has_bit","text":"<pre><code>has_bit(quality_array: ndarray, bit: int) -&gt; ndarray\n</code></pre> <p>Checks if a specific bit is set in each element of a quality flag array.</p> <p>Parameters:</p> <ul> <li> <code>quality_array</code>               (<code>ndarray</code>)           \u2013            <p>A NumPy array of integers (quality flags).</p> </li> <li> <code>bit</code>               (<code>int</code>)           \u2013            <p>The bit position to check (1-based index, where 1 is the LSB). Must be between 1 and 16 (inclusive).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A boolean NumPy array of the same shape as <code>quality_array</code>, where True indicates that the specified <code>bit</code> is set (1) in the corresponding quality flag integer.</p> </li> </ul>"}]}